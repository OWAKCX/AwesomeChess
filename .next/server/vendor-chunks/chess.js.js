"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chess.js";
exports.ids = ["vendor-chunks/chess.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/chess.js/dist/esm/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/esm/chess.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BISHOP: () => (/* binding */ BISHOP),\n/* harmony export */   BLACK: () => (/* binding */ BLACK),\n/* harmony export */   Chess: () => (/* binding */ Chess),\n/* harmony export */   DEFAULT_POSITION: () => (/* binding */ DEFAULT_POSITION),\n/* harmony export */   KING: () => (/* binding */ KING),\n/* harmony export */   KNIGHT: () => (/* binding */ KNIGHT),\n/* harmony export */   Move: () => (/* binding */ Move),\n/* harmony export */   PAWN: () => (/* binding */ PAWN),\n/* harmony export */   QUEEN: () => (/* binding */ QUEEN),\n/* harmony export */   ROOK: () => (/* binding */ ROOK),\n/* harmony export */   SEVEN_TAG_ROSTER: () => (/* binding */ SEVEN_TAG_ROSTER),\n/* harmony export */   SQUARES: () => (/* binding */ SQUARES),\n/* harmony export */   WHITE: () => (/* binding */ WHITE),\n/* harmony export */   validateFen: () => (/* binding */ validateFen),\n/* harmony export */   xoroshiro128: () => (/* binding */ xoroshiro128)\n/* harmony export */ });\n// @generated by Peggy 4.2.0.\n//\n// https://peggyjs.org/\n\n\n\n  function rootNode(comment) {\n  \treturn comment !== null ? { comment, variations: [] } : { variations: []}\n  }\n\n  function node(move, suffix, nag, comment, variations) {\n  \tconst node = { move, variations };\n\n    if (suffix) {\n    \tnode.suffix = suffix;\n    }\n\n    if (nag) {\n    \tnode.nag = nag;\n    }\n\n    if (comment !== null) {\n    \tnode.comment = comment;\n    }\n\n    return node\n  }\n\n  function lineToTree(...nodes) {\n  \tconst [root, ...rest] = nodes;\n\n    let parent = root;\n\n    for (const child of rest) {\n    \tif (child !== null) {\n        \tparent.variations = [child, ...child.variations];\n            child.variations = [];\n            parent = child;\n        }\n    }\n\n  \treturn root\n  }\n\n  function pgn(headers, game) {\n  \tif (game.marker && game.marker.comment) {\n    \tlet node = game.root;\n        while (true) {\n        \tconst next = node.variations[0];\n            if (!next) {\n            \tnode.comment = game.marker.comment;\n            \tbreak\n            }\n            node = next;\n        }\n    }\n\n  \treturn {\n    \theaders,\n        root: game.root,\n        result: (game.marker && game.marker.result) ?? undefined\n    }\n  }\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n      ? this.location.source.offset(s)\n      : s;\n    var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", offset_s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + offset_s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { pgn: peg$parsepgn };\n  var peg$startRuleFunction = peg$parsepgn;\n\n  var peg$c0 = \"[\";\n  var peg$c1 = \"\\\"\";\n  var peg$c2 = \"]\";\n  var peg$c3 = \".\";\n  var peg$c4 = \"O-O-O\";\n  var peg$c5 = \"O-O\";\n  var peg$c6 = \"0-0-0\";\n  var peg$c7 = \"0-0\";\n  var peg$c8 = \"$\";\n  var peg$c9 = \"{\";\n  var peg$c10 = \"}\";\n  var peg$c11 = \";\";\n  var peg$c12 = \"(\";\n  var peg$c13 = \")\";\n  var peg$c14 = \"1-0\";\n  var peg$c15 = \"0-1\";\n  var peg$c16 = \"1/2-1/2\";\n  var peg$c17 = \"*\";\n\n  var peg$r0 = /^[a-zA-Z]/;\n  var peg$r1 = /^[^\"]/;\n  var peg$r2 = /^[0-9]/;\n  var peg$r3 = /^[.]/;\n  var peg$r4 = /^[a-zA-Z1-8\\-=]/;\n  var peg$r5 = /^[+#]/;\n  var peg$r6 = /^[!?]/;\n  var peg$r7 = /^[^}]/;\n  var peg$r8 = /^[^\\r\\n]/;\n  var peg$r9 = /^[ \\t\\r\\n]/;\n\n  var peg$e0 = peg$otherExpectation(\"tag pair\");\n  var peg$e1 = peg$literalExpectation(\"[\", false);\n  var peg$e2 = peg$literalExpectation(\"\\\"\", false);\n  var peg$e3 = peg$literalExpectation(\"]\", false);\n  var peg$e4 = peg$otherExpectation(\"tag name\");\n  var peg$e5 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false);\n  var peg$e6 = peg$otherExpectation(\"tag value\");\n  var peg$e7 = peg$classExpectation([\"\\\"\"], true, false);\n  var peg$e8 = peg$otherExpectation(\"move number\");\n  var peg$e9 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e10 = peg$literalExpectation(\".\", false);\n  var peg$e11 = peg$classExpectation([\".\"], false, false);\n  var peg$e12 = peg$otherExpectation(\"standard algebraic notation\");\n  var peg$e13 = peg$literalExpectation(\"O-O-O\", false);\n  var peg$e14 = peg$literalExpectation(\"O-O\", false);\n  var peg$e15 = peg$literalExpectation(\"0-0-0\", false);\n  var peg$e16 = peg$literalExpectation(\"0-0\", false);\n  var peg$e17 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"1\", \"8\"], \"-\", \"=\"], false, false);\n  var peg$e18 = peg$classExpectation([\"+\", \"#\"], false, false);\n  var peg$e19 = peg$otherExpectation(\"suffix annotation\");\n  var peg$e20 = peg$classExpectation([\"!\", \"?\"], false, false);\n  var peg$e21 = peg$otherExpectation(\"NAG\");\n  var peg$e22 = peg$literalExpectation(\"$\", false);\n  var peg$e23 = peg$otherExpectation(\"brace comment\");\n  var peg$e24 = peg$literalExpectation(\"{\", false);\n  var peg$e25 = peg$classExpectation([\"}\"], true, false);\n  var peg$e26 = peg$literalExpectation(\"}\", false);\n  var peg$e27 = peg$otherExpectation(\"rest of line comment\");\n  var peg$e28 = peg$literalExpectation(\";\", false);\n  var peg$e29 = peg$classExpectation([\"\\r\", \"\\n\"], true, false);\n  var peg$e30 = peg$otherExpectation(\"variation\");\n  var peg$e31 = peg$literalExpectation(\"(\", false);\n  var peg$e32 = peg$literalExpectation(\")\", false);\n  var peg$e33 = peg$otherExpectation(\"game termination marker\");\n  var peg$e34 = peg$literalExpectation(\"1-0\", false);\n  var peg$e35 = peg$literalExpectation(\"0-1\", false);\n  var peg$e36 = peg$literalExpectation(\"1/2-1/2\", false);\n  var peg$e37 = peg$literalExpectation(\"*\", false);\n  var peg$e38 = peg$otherExpectation(\"whitespace\");\n  var peg$e39 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false);\n\n  var peg$f0 = function(headers, game) { return pgn(headers, game) };\n  var peg$f1 = function(tagPairs) { return Object.fromEntries(tagPairs) };\n  var peg$f2 = function(tagName, tagValue) { return [tagName, tagValue] };\n  var peg$f3 = function(root, marker) { return { root, marker} };\n  var peg$f4 = function(comment, moves) { return lineToTree(rootNode(comment), ...moves.flat()) };\n  var peg$f5 = function(san, suffix, nag, comment, variations) { return node(san, suffix, nag, comment, variations) };\n  var peg$f6 = function(nag) { return nag };\n  var peg$f7 = function(comment) { return comment.replace(/[\\r\\n]+/g, \" \") };\n  var peg$f8 = function(comment) { return comment.trim() };\n  var peg$f9 = function(line) { return line };\n  var peg$f10 = function(result, comment) { return { result, comment } };\n  var peg$currPos = options.peg$currPos | 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = peg$currPos;\n  var peg$maxFailExpected = options.peg$maxFailExpected || [];\n  var peg$silentFails = options.peg$silentFails | 0;\n\n  var peg$result;\n\n  if (options.startRule) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      if (pos >= peg$posDetailsCache.length) {\n        p = peg$posDetailsCache.length - 1;\n      } else {\n        p = pos;\n        while (!peg$posDetailsCache[--p]) {}\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos, offset) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    var res = {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n    return res;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepgn() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsetagPairSection();\n    s2 = peg$parsemoveTextSection();\n    s0 = peg$f0(s1, s2);\n\n    return s0;\n  }\n\n  function peg$parsetagPairSection() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsetagPair();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsetagPair();\n    }\n    s2 = peg$parse_();\n    s0 = peg$f1(s1);\n\n    return s0;\n  }\n\n  function peg$parsetagPair() {\n    var s0, s2, s4, s6, s7, s8, s10;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s2 = peg$c0;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    if (s2 !== peg$FAILED) {\n      peg$parse_();\n      s4 = peg$parsetagName();\n      if (s4 !== peg$FAILED) {\n        peg$parse_();\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s6 = peg$c1;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e2); }\n        }\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parsetagValue();\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s8 = peg$c1;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s8 !== peg$FAILED) {\n            peg$parse_();\n            if (input.charCodeAt(peg$currPos) === 93) {\n              s10 = peg$c2;\n              peg$currPos++;\n            } else {\n              s10 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e3); }\n            }\n            if (s10 !== peg$FAILED) {\n              s0 = peg$f2(s4, s7);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetagName() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r0.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = input.charAt(peg$currPos);\n        if (peg$r0.test(s2)) {\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e5); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetagValue() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r1.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = input.charAt(peg$currPos);\n      if (peg$r1.test(s2)) {\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n      }\n    }\n    s0 = input.substring(s0, peg$currPos);\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e6); }\n\n    return s0;\n  }\n\n  function peg$parsemoveTextSection() {\n    var s0, s1, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseline();\n    peg$parse_();\n    s3 = peg$parsegameTerminationMarker();\n    if (s3 === peg$FAILED) {\n      s3 = null;\n    }\n    peg$parse_();\n    s0 = peg$f3(s1, s3);\n\n    return s0;\n  }\n\n  function peg$parseline() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecomment();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = [];\n    s3 = peg$parsemove();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$parsemove();\n    }\n    s0 = peg$f4(s1, s2);\n\n    return s0;\n  }\n\n  function peg$parsemove() {\n    var s0, s4, s5, s6, s7, s8, s9, s10;\n\n    s0 = peg$currPos;\n    peg$parse_();\n    peg$parsemoveNumber();\n    peg$parse_();\n    s4 = peg$parsesan();\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parsesuffixAnnotation();\n      if (s5 === peg$FAILED) {\n        s5 = null;\n      }\n      s6 = [];\n      s7 = peg$parsenag();\n      while (s7 !== peg$FAILED) {\n        s6.push(s7);\n        s7 = peg$parsenag();\n      }\n      s7 = peg$parse_();\n      s8 = peg$parsecomment();\n      if (s8 === peg$FAILED) {\n        s8 = null;\n      }\n      s9 = [];\n      s10 = peg$parsevariation();\n      while (s10 !== peg$FAILED) {\n        s9.push(s10);\n        s10 = peg$parsevariation();\n      }\n      s0 = peg$f5(s4, s5, s6, s8, s9);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveNumber() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r2.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = input.charAt(peg$currPos);\n      if (peg$r2.test(s2)) {\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n    }\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c3;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse_();\n      s4 = [];\n      s5 = input.charAt(peg$currPos);\n      if (peg$r3.test(s5)) {\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e11); }\n      }\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = input.charAt(peg$currPos);\n        if (peg$r3.test(s5)) {\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e11); }\n        }\n      }\n      s1 = [s1, s2, s3, s4];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesan() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c4) {\n      s2 = peg$c4;\n      peg$currPos += 5;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n    if (s2 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c5) {\n        s2 = peg$c5;\n        peg$currPos += 3;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e14); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c6) {\n          s2 = peg$c6;\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e15); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c7) {\n            s2 = peg$c7;\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e16); }\n          }\n          if (s2 === peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = input.charAt(peg$currPos);\n            if (peg$r0.test(s3)) {\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e5); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = [];\n              s5 = input.charAt(peg$currPos);\n              if (peg$r4.test(s5)) {\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e17); }\n              }\n              if (s5 !== peg$FAILED) {\n                while (s5 !== peg$FAILED) {\n                  s4.push(s5);\n                  s5 = input.charAt(peg$currPos);\n                  if (peg$r4.test(s5)) {\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e17); }\n                  }\n                }\n              } else {\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = input.charAt(peg$currPos);\n      if (peg$r5.test(s3)) {\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e18); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesuffixAnnotation() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r6.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e20); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (s1.length >= 2) {\n        s2 = peg$FAILED;\n      } else {\n        s2 = input.charAt(peg$currPos);\n        if (peg$r6.test(s2)) {\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e20); }\n        }\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenag() {\n    var s0, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s2 = peg$c8;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = input.charAt(peg$currPos);\n      if (peg$r2.test(s5)) {\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n      if (s5 !== peg$FAILED) {\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = input.charAt(peg$currPos);\n          if (peg$r2.test(s5)) {\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e9); }\n          }\n        }\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = input.substring(s3, peg$currPos);\n      } else {\n        s3 = s4;\n      }\n      if (s3 !== peg$FAILED) {\n        s0 = peg$f6(s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0;\n\n    s0 = peg$parsebraceComment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parserestOfLineComment();\n    }\n\n    return s0;\n  }\n\n  function peg$parsebraceComment() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c9;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e24); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = input.charAt(peg$currPos);\n      if (peg$r7.test(s4)) {\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e25); }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = input.charAt(peg$currPos);\n        if (peg$r7.test(s4)) {\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e25); }\n        }\n      }\n      s2 = input.substring(s2, peg$currPos);\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s3 = peg$c10;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e26); }\n      }\n      if (s3 !== peg$FAILED) {\n        s0 = peg$f7(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e23); }\n    }\n\n    return s0;\n  }\n\n  function peg$parserestOfLineComment() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 59) {\n      s1 = peg$c11;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e28); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = input.charAt(peg$currPos);\n      if (peg$r8.test(s4)) {\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e29); }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = input.charAt(peg$currPos);\n        if (peg$r8.test(s4)) {\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e29); }\n        }\n      }\n      s2 = input.substring(s2, peg$currPos);\n      s0 = peg$f8(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e27); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsevariation() {\n    var s0, s2, s3, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s2 = peg$c12;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e31); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseline();\n      if (s3 !== peg$FAILED) {\n        peg$parse_();\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s5 = peg$c13;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e32); }\n        }\n        if (s5 !== peg$FAILED) {\n          s0 = peg$f9(s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      if (peg$silentFails === 0) { peg$fail(peg$e30); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsegameTerminationMarker() {\n    var s0, s1, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c14) {\n      s1 = peg$c14;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e34); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c15) {\n        s1 = peg$c15;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c16) {\n          s1 = peg$c16;\n          peg$currPos += 7;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e36); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s1 = peg$c17;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e37); }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$parse_();\n      s3 = peg$parsecomment();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s0 = peg$f10(s1, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e33); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    s1 = input.charAt(peg$currPos);\n    if (peg$r9.test(s1)) {\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e39); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = input.charAt(peg$currPos);\n      if (peg$r9.test(s1)) {\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e39); }\n      }\n    }\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e38); }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (options.peg$library) {\n    return /** @type {any} */ ({\n      peg$result,\n      peg$currPos,\n      peg$FAILED,\n      peg$maxFailExpected,\n      peg$maxFailPos\n    });\n  }\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\n/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nconst MASK64 = 0xffffffffffffffffn;\nfunction rotl(x, k) {\n    return ((x << k) | (x >> (64n - k))) & 0xffffffffffffffffn;\n}\nfunction wrappingMul(x, y) {\n    return (x * y) & MASK64;\n}\n// xoroshiro128**\nfunction xoroshiro128(state) {\n    return function () {\n        let s0 = BigInt(state & MASK64);\n        let s1 = BigInt((state >> 64n) & MASK64);\n        const result = wrappingMul(rotl(wrappingMul(s0, 5n), 7n), 9n);\n        s1 ^= s0;\n        s0 = (rotl(s0, 24n) ^ s1 ^ (s1 << 16n)) & MASK64;\n        s1 = rotl(s1, 37n);\n        state = (s1 << 64n) | s0;\n        return result;\n    };\n}\nconst rand = xoroshiro128(0xa187eb39cdcaed8f31c4b365b102e01en);\nconst PIECE_KEYS = Array.from({ length: 2 }, () => Array.from({ length: 6 }, () => Array.from({ length: 128 }, () => rand())));\nconst EP_KEYS = Array.from({ length: 8 }, () => rand());\nconst CASTLING_KEYS = Array.from({ length: 16 }, () => rand());\nconst SIDE_KEY = rand();\nconst WHITE = 'w';\nconst BLACK = 'b';\nconst PAWN = 'p';\nconst KNIGHT = 'n';\nconst BISHOP = 'b';\nconst ROOK = 'r';\nconst QUEEN = 'q';\nconst KING = 'k';\nconst DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nclass Move {\n    color;\n    from;\n    to;\n    piece;\n    captured;\n    promotion;\n    /**\n     * @deprecated This field is deprecated and will be removed in version 2.0.0.\n     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n     * `isBigPawn`\n     */\n    flags;\n    san;\n    lan;\n    before;\n    after;\n    constructor(chess, internal) {\n        const { color, piece, from, to, flags, captured, promotion } = internal;\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        this.color = color;\n        this.piece = piece;\n        this.from = fromAlgebraic;\n        this.to = toAlgebraic;\n        /*\n         * HACK: The chess['_method']() calls below invoke private methods in the\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n         * code cleaner elsewhere.\n         */\n        this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }));\n        this.lan = fromAlgebraic + toAlgebraic;\n        this.before = chess.fen();\n        // Generate the FEN for the 'after' key\n        chess['_makeMove'](internal);\n        this.after = chess.fen();\n        chess['_undoMove']();\n        // Build the text representation of the move flags\n        this.flags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                this.flags += FLAGS[flag];\n            }\n        }\n        if (captured) {\n            this.captured = captured;\n        }\n        if (promotion) {\n            this.promotion = promotion;\n            this.lan += promotion;\n        }\n    }\n    isCapture() {\n        return this.flags.indexOf(FLAGS['CAPTURE']) > -1;\n    }\n    isPromotion() {\n        return this.flags.indexOf(FLAGS['PROMOTION']) > -1;\n    }\n    isEnPassant() {\n        return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1;\n    }\n    isKingsideCastle() {\n        return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1;\n    }\n    isQueensideCastle() {\n        return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1;\n    }\n    isBigPawn() {\n        return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1;\n    }\n}\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n    NULL_MOVE: '-',\n};\n// prettier-ignore\nconst SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n    NULL_MOVE: 128,\n};\n/* eslint-disable @typescript-eslint/naming-convention */\n// these are required, according to spec\nconst SEVEN_TAG_ROSTER = {\n    Event: '?',\n    Site: '?',\n    Date: '????.??.??',\n    Round: '?',\n    White: '?',\n    Black: '?',\n    Result: '*',\n};\n/**\n * These nulls are placeholders to fix the order of tags (as they appear in PGN spec); null values will be\n * eliminated in getHeaders()\n */\nconst SUPLEMENTAL_TAGS = {\n    WhiteTitle: null,\n    BlackTitle: null,\n    WhiteElo: null,\n    BlackElo: null,\n    WhiteUSCF: null,\n    BlackUSCF: null,\n    WhiteNA: null,\n    BlackNA: null,\n    WhiteType: null,\n    BlackType: null,\n    EventDate: null,\n    EventSponsor: null,\n    Section: null,\n    Stage: null,\n    Board: null,\n    Opening: null,\n    Variation: null,\n    SubVariation: null,\n    ECO: null,\n    NIC: null,\n    Time: null,\n    UTCTime: null,\n    UTCDate: null,\n    TimeControl: null,\n    SetUp: null,\n    FEN: null,\n    Termination: null,\n    Annotator: null,\n    Mode: null,\n    PlyCount: null,\n};\nconst HEADER_TEMPLATE = {\n    ...SEVEN_TAG_ROSTER,\n    ...SUPLEMENTAL_TAGS,\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE,\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst SAN_NULLMOVE = '--';\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: some pawns are on the edge rows',\n        };\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nclass Chess {\n    _board = new Array(128);\n    _turn = WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    _hash = 0n;\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = new Map();\n    constructor(fen = DEFAULT_POSITION, { skipValidation = false } = {}) {\n        this.load(fen, { skipValidation });\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : { ...HEADER_TEMPLATE };\n        this._hash = this._computeHash();\n        this._positionCount = new Map();\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */\n        this._header['SetUp'] = null;\n        this._header['FEN'] = null;\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({ preserveHeaders });\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._hash = this._computeHash();\n        this._updateSetup(fen);\n        this._incPositionCount();\n    }\n    fen({ forceEnpassantSquare = false, } = {}) {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            if (forceEnpassantSquare) {\n                epSquare = algebraic(this._epSquare);\n            }\n            else {\n                const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n                const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n                for (const square of squares) {\n                    // is the square off the board?\n                    if (square & 0x88) {\n                        continue;\n                    }\n                    const color = this._turn;\n                    // is there a pawn that can capture the epSquare?\n                    if (this._board[square]?.color === color &&\n                        this._board[square]?.type === PAWN) {\n                        // if the pawn makes an ep capture, does it leave its king in check?\n                        this._makeMove({\n                            color,\n                            from: square,\n                            to: this._epSquare,\n                            piece: PAWN,\n                            captured: PAWN,\n                            flags: BITS.EP_CAPTURE,\n                        });\n                        const isLegal = !this._isKingAttacked(color);\n                        this._undoMove();\n                        // if ep is legal, break and set the ep square in the FEN output\n                        if (isLegal) {\n                            epSquare = algebraic(this._epSquare);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    _pieceKey(i) {\n        if (!this._board[i]) {\n            return 0n;\n        }\n        const { color, type } = this._board[i];\n        const colorIndex = {\n            w: 0,\n            b: 1,\n        }[color];\n        const typeIndex = {\n            p: 0,\n            n: 1,\n            b: 2,\n            r: 3,\n            q: 4,\n            k: 5,\n        }[type];\n        return PIECE_KEYS[colorIndex][typeIndex][i];\n    }\n    _epKey() {\n        return this._epSquare === EMPTY ? 0n : EP_KEYS[this._epSquare & 7];\n    }\n    _castlingKey() {\n        const index = (this._castling.w >> 5) | (this._castling.b >> 3);\n        return CASTLING_KEYS[index];\n    }\n    _computeHash() {\n        let hash = 0n;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            if (this._board[i]) {\n                hash ^= this._pieceKey(i);\n            }\n        }\n        hash ^= this._epKey();\n        hash ^= this._castlingKey();\n        if (this._turn === 'b') {\n            hash ^= SIDE_KEY;\n        }\n        return hash;\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            this._header['SetUp'] = null;\n            this._header['FEN'] = null;\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]];\n    }\n    findPiece(piece) {\n        const squares = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (!this._board[i] || this._board[i]?.color !== piece.color) {\n                continue;\n            }\n            // check if square contains the requested piece\n            if (this._board[i].color === piece.color &&\n                this._board[i].type === piece.type) {\n                squares.push(algebraic(i));\n            }\n        }\n        return squares;\n    }\n    put({ type, color }, square) {\n        if (this._put({ type, color }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _set(sq, piece) {\n        this._hash ^= this._pieceKey(sq);\n        this._board[sq] = piece;\n        this._hash ^= this._pieceKey(sq);\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._set(sq, { type: type, color: color });\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    _clear(sq) {\n        this._hash ^= this._pieceKey(sq);\n        delete this._board[sq];\n    }\n    remove(square) {\n        const piece = this.get(square);\n        this._clear(Ox88[square]);\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        this._hash ^= this._castlingKey();\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === KING &&\n            this._board[Ox88.e1]?.color === WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === KING &&\n            this._board[Ox88.e8]?.color === BLACK;\n        if (!whiteKingInPlace ||\n            this._board[Ox88.a1]?.type !== ROOK ||\n            this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= -65;\n        }\n        if (!whiteKingInPlace ||\n            this._board[Ox88.h1]?.type !== ROOK ||\n            this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= -33;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.a8]?.type !== ROOK ||\n            this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= -65;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.h8]?.type !== ROOK ||\n            this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= -33;\n        }\n        this._hash ^= this._castlingKey();\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== PAWN) {\n            this._hash ^= this._epKey();\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._hash ^= this._epKey();\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square, verbose) {\n        const attackers = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if ((difference > 0 && piece.color === WHITE) ||\n                        (difference <= 0 && piece.color === BLACK)) {\n                        if (!verbose) {\n                            return true;\n                        }\n                        else {\n                            attackers.push(algebraic(i));\n                        }\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k') {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n            }\n        }\n        if (verbose) {\n            return attackers;\n        }\n        else {\n            return false;\n        }\n    }\n    attackers(square, attackedBy) {\n        if (!attackedBy) {\n            return this._attacked(this._turn, Ox88[square], true);\n        }\n        else {\n            return this._attacked(attackedBy, Ox88[square], true);\n        }\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    hash() {\n        return this._hash.toString(16);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this._hash) >= 3;\n    }\n    isDrawByFiftyMoves() {\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n    }\n    isDraw() {\n        return (this.isDrawByFiftyMoves() ||\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => new Move(this, move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (move === null) {\n            moveObj = this._moveFromSan(SAN_NULLMOVE, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        //disallow null moves when in check\n        if (this.isCheck() && moveObj.flags & BITS.NULL_MOVE) {\n            throw new Error('Null move not allowed when in check');\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = new Move(this, moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount();\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _movePiece(from, to) {\n        this._hash ^= this._pieceKey(from);\n        this._board[to] = this._board[from];\n        delete this._board[from];\n        this._hash ^= this._pieceKey(to);\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        if (move.flags & BITS.NULL_MOVE) {\n            if (us === BLACK) {\n                this._moveNumber++;\n            }\n            this._halfMoves++;\n            this._turn = them;\n            this._epSquare = EMPTY;\n            return;\n        }\n        this._hash ^= this._epKey();\n        this._hash ^= this._castlingKey();\n        if (move.captured) {\n            this._hash ^= this._pieceKey(move.to);\n        }\n        this._movePiece(move.from, move.to);\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                this._clear(move.to - 16);\n            }\n            else {\n                this._clear(move.to + 16);\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._clear(move.to);\n            this._set(move.to, { type: move.promotion, color: us });\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._movePiece(castlingFrom, castlingTo);\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._movePiece(castlingFrom, castlingTo);\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        this._hash ^= this._castlingKey();\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            let epSquare;\n            if (us === BLACK) {\n                epSquare = move.to - 16;\n            }\n            else {\n                epSquare = move.to + 16;\n            }\n            if ((!((move.to - 1) & 0x88) &&\n                this._board[move.to - 1]?.type === PAWN &&\n                this._board[move.to - 1]?.color === them) ||\n                (!((move.to + 1) & 0x88) &&\n                    this._board[move.to + 1]?.type === PAWN &&\n                    this._board[move.to + 1]?.color === them)) {\n                this._epSquare = epSquare;\n                this._hash ^= this._epKey();\n            }\n            else {\n                this._epSquare = EMPTY;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n        this._hash ^= SIDE_KEY;\n    }\n    undo() {\n        const hash = this._hash;\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = new Move(this, move);\n            this._decPositionCount(hash);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        this._hash ^= this._epKey();\n        this._hash ^= this._castlingKey();\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        this._hash ^= this._epKey();\n        this._hash ^= this._castlingKey();\n        this._hash ^= SIDE_KEY;\n        const us = this._turn;\n        const them = swapColor(us);\n        if (move.flags & BITS.NULL_MOVE) {\n            return move;\n        }\n        this._movePiece(move.to, move.from);\n        // to undo any promotions\n        if (move.piece) {\n            this._clear(move.from);\n            this._set(move.from, { type: move.piece, color: us });\n        }\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._set(index, { type: PAWN, color: them });\n            }\n            else {\n                // regular capture\n                this._set(move.to, { type: move.captured, color: them });\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._movePiece(castlingFrom, castlingTo);\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             *\n             * By using HEADER_TEMPLATE, the order of tags should be preserved; we\n             * do have to check for null placeholders, though, and omit them\n             */\n            const headerTag = this._header[i];\n            if (headerTag)\n                result.push(`[${i} \"${this._header[i]}\"]` + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result? (there ALWAYS has to be a result according to spec; see Seven Tag Roster)\n        moves.push(this._header.Result || '*');\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    /**\n     * @deprecated Use `setHeader` and `getHeaders` instead. This method will return null header tags (which is not what you want)\n     */\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    // TODO: value validation per spec\n    setHeader(key, value) {\n        this._header[key] = value ?? SEVEN_TAG_ROSTER[key] ?? null;\n        return this.getHeaders();\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            this._header[key] = SEVEN_TAG_ROSTER[key] || null;\n            return true;\n        }\n        return false;\n    }\n    // return only non-null headers (omit placemarker nulls)\n    getHeaders() {\n        const nonNullHeaders = {};\n        for (const [key, value] of Object.entries(this._header)) {\n            if (value !== null) {\n                nonNullHeaders[key] = value;\n            }\n        }\n        return nonNullHeaders;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        // If newlineChar is not the default, replace all instances with \\n\n        if (newlineChar !== '\\r?\\n') {\n            pgn = pgn.replace(new RegExp(newlineChar, 'g'), '\\n');\n        }\n        const parsedPgn = peg$parse(pgn);\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsedPgn.headers;\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, { preserveHeaders: true });\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // don't clear the headers when loading\n                this.load(headers['FEN'], { preserveHeaders: true });\n            }\n        }\n        let node = parsedPgn.root;\n        while (node) {\n            if (node.move) {\n                const move = this._moveFromSan(node.move, strict);\n                if (move == null) {\n                    throw new Error(`Invalid move in PGN: ${node.move}`);\n                }\n                else {\n                    this._makeMove(move);\n                    this._incPositionCount();\n                }\n            }\n            if (node.comment !== undefined) {\n                this._comments[this.fen()] = node.comment;\n            }\n            node = node.variations[0];\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        const result = parsedPgn.result;\n        if (result &&\n            Object.keys(this._header).length &&\n            this._header['Result'] !== result) {\n            this.setHeader('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else if (move.flags & BITS.NULL_MOVE) {\n            return SAN_NULLMOVE;\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        let cleanMove = strippedSan(move);\n        if (!strict) {\n            if (cleanMove === '0-0') {\n                cleanMove = 'O-O';\n            }\n            else if (cleanMove === '0-0-0') {\n                cleanMove = 'O-O-O';\n            }\n        }\n        //first implementation of null with a dummy move (black king moves from a8 to a8), maybe this can be implemented better\n        if (cleanMove == SAN_NULLMOVE) {\n            const res = {\n                color: this._turn,\n                from: 0,\n                to: 0,\n                piece: 'k',\n                flags: BITS.NULL_MOVE,\n            };\n            return res;\n        }\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove ===\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    setTurn(color) {\n        if (this._turn == color) {\n            return false;\n        }\n        this.move('--');\n        return true;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(new Move(this, move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. Old positions are removed from the map if their counts are reduced to 0.\n     */\n    _getPositionCount(hash) {\n        return this._positionCount.get(hash) ?? 0;\n    }\n    _incPositionCount() {\n        this._positionCount.set(this._hash, (this._positionCount.get(this._hash) ?? 0) + 1);\n    }\n    _decPositionCount(hash) {\n        const currentCount = this._positionCount.get(hash) ?? 0;\n        if (currentCount === 1) {\n            this._positionCount.delete(hash);\n        }\n        else {\n            this._positionCount.set(hash, currentCount - 1);\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    /**\n     * @deprecated Renamed to `removeComment` for consistency\n     */\n    deleteComment() {\n        return this.removeComment();\n    }\n    removeComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    /**\n     * @deprecated Renamed to `removeComments` for consistency\n     */\n    deleteComments() {\n        return this.removeComments();\n    }\n    removeComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [KING, QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return ((rights[KING] === undefined || rights[KING] === result[KING]) &&\n            (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]));\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n\n\n//# sourceMappingURL=chess.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9lc20vY2hlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQSwrQkFBK0IsMEJBQTBCLElBQUk7QUFDN0Q7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcscUJBQXFCLFdBQVcscUJBQXFCLGFBQWE7QUFDN0csNkJBQTZCLFdBQVc7QUFDeEMsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBDQUEwQztBQUNwRCxVQUFVLDBDQUEwQztBQUNwRDtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkIsd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0NBQW9DO0FBQ3pEO0FBQ0Esd0JBQXdCLDBDQUEwQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQ0FBaUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQixJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNKO0FBQ3RKIiwic291cmNlcyI6WyIvaG9tZS91YnVudHUvY2hlc3MtYXBwL25vZGVfbW9kdWxlcy9jaGVzcy5qcy9kaXN0L2VzbS9jaGVzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZ2VuZXJhdGVkIGJ5IFBlZ2d5IDQuMi4wLlxuLy9cbi8vIGh0dHBzOi8vcGVnZ3lqcy5vcmcvXG5cblxuXG4gIGZ1bmN0aW9uIHJvb3ROb2RlKGNvbW1lbnQpIHtcbiAgXHRyZXR1cm4gY29tbWVudCAhPT0gbnVsbCA/IHsgY29tbWVudCwgdmFyaWF0aW9uczogW10gfSA6IHsgdmFyaWF0aW9uczogW119XG4gIH1cblxuICBmdW5jdGlvbiBub2RlKG1vdmUsIHN1ZmZpeCwgbmFnLCBjb21tZW50LCB2YXJpYXRpb25zKSB7XG4gIFx0Y29uc3Qgbm9kZSA9IHsgbW92ZSwgdmFyaWF0aW9ucyB9O1xuXG4gICAgaWYgKHN1ZmZpeCkge1xuICAgIFx0bm9kZS5zdWZmaXggPSBzdWZmaXg7XG4gICAgfVxuXG4gICAgaWYgKG5hZykge1xuICAgIFx0bm9kZS5uYWcgPSBuYWc7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1lbnQgIT09IG51bGwpIHtcbiAgICBcdG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmVUb1RyZWUoLi4ubm9kZXMpIHtcbiAgXHRjb25zdCBbcm9vdCwgLi4ucmVzdF0gPSBub2RlcztcblxuICAgIGxldCBwYXJlbnQgPSByb290O1xuXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiByZXN0KSB7XG4gICAgXHRpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgXHRwYXJlbnQudmFyaWF0aW9ucyA9IFtjaGlsZCwgLi4uY2hpbGQudmFyaWF0aW9uc107XG4gICAgICAgICAgICBjaGlsZC52YXJpYXRpb25zID0gW107XG4gICAgICAgICAgICBwYXJlbnQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH1cblxuICBcdHJldHVybiByb290XG4gIH1cblxuICBmdW5jdGlvbiBwZ24oaGVhZGVycywgZ2FtZSkge1xuICBcdGlmIChnYW1lLm1hcmtlciAmJiBnYW1lLm1hcmtlci5jb21tZW50KSB7XG4gICAgXHRsZXQgbm9kZSA9IGdhbWUucm9vdDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgXHRjb25zdCBuZXh0ID0gbm9kZS52YXJpYXRpb25zWzBdO1xuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBcdG5vZGUuY29tbWVudCA9IGdhbWUubWFya2VyLmNvbW1lbnQ7XG4gICAgICAgICAgICBcdGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICBcdHJldHVybiB7XG4gICAgXHRoZWFkZXJzLFxuICAgICAgICByb290OiBnYW1lLnJvb3QsXG4gICAgICAgIHJlc3VsdDogKGdhbWUubWFya2VyICYmIGdhbWUubWFya2VyLnJlc3VsdCkgPz8gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbmZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gIGZ1bmN0aW9uIEMoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICBDLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBDKCk7XG59XG5cbmZ1bmN0aW9uIHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIGxvY2F0aW9uKSB7XG4gIHZhciBzZWxmID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQgQ2hlY2sgaXMgYSBuZWNlc3NhcnkgZXZpbCB0byBzdXBwb3J0IG9sZGVyIGVudmlyb25tZW50c1xuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHNlbGYsIHBlZyRTeW50YXhFcnJvci5wcm90b3R5cGUpO1xuICB9XG4gIHNlbGYuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgc2VsZi5mb3VuZCA9IGZvdW5kO1xuICBzZWxmLmxvY2F0aW9uID0gbG9jYXRpb247XG4gIHNlbGYubmFtZSA9IFwiU3ludGF4RXJyb3JcIjtcbiAgcmV0dXJuIHNlbGY7XG59XG5cbnBlZyRzdWJjbGFzcyhwZWckU3ludGF4RXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcGVnJHBhZEVuZChzdHIsIHRhcmdldExlbmd0aCwgcGFkU3RyaW5nKSB7XG4gIHBhZFN0cmluZyA9IHBhZFN0cmluZyB8fCBcIiBcIjtcbiAgaWYgKHN0ci5sZW5ndGggPiB0YXJnZXRMZW5ndGgpIHsgcmV0dXJuIHN0cjsgfVxuICB0YXJnZXRMZW5ndGggLT0gc3RyLmxlbmd0aDtcbiAgcGFkU3RyaW5nICs9IHBhZFN0cmluZy5yZXBlYXQodGFyZ2V0TGVuZ3RoKTtcbiAgcmV0dXJuIHN0ciArIHBhZFN0cmluZy5zbGljZSgwLCB0YXJnZXRMZW5ndGgpO1xufVxuXG5wZWckU3ludGF4RXJyb3IucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKHNvdXJjZXMpIHtcbiAgdmFyIHN0ciA9IFwiRXJyb3I6IFwiICsgdGhpcy5tZXNzYWdlO1xuICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgIHZhciBzcmMgPSBudWxsO1xuICAgIHZhciBrO1xuICAgIGZvciAoayA9IDA7IGsgPCBzb3VyY2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICBpZiAoc291cmNlc1trXS5zb3VyY2UgPT09IHRoaXMubG9jYXRpb24uc291cmNlKSB7XG4gICAgICAgIHNyYyA9IHNvdXJjZXNba10udGV4dC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcyA9IHRoaXMubG9jYXRpb24uc3RhcnQ7XG4gICAgdmFyIG9mZnNldF9zID0gKHRoaXMubG9jYXRpb24uc291cmNlICYmICh0eXBlb2YgdGhpcy5sb2NhdGlvbi5zb3VyY2Uub2Zmc2V0ID09PSBcImZ1bmN0aW9uXCIpKVxuICAgICAgPyB0aGlzLmxvY2F0aW9uLnNvdXJjZS5vZmZzZXQocylcbiAgICAgIDogcztcbiAgICB2YXIgbG9jID0gdGhpcy5sb2NhdGlvbi5zb3VyY2UgKyBcIjpcIiArIG9mZnNldF9zLmxpbmUgKyBcIjpcIiArIG9mZnNldF9zLmNvbHVtbjtcbiAgICBpZiAoc3JjKSB7XG4gICAgICB2YXIgZSA9IHRoaXMubG9jYXRpb24uZW5kO1xuICAgICAgdmFyIGZpbGxlciA9IHBlZyRwYWRFbmQoXCJcIiwgb2Zmc2V0X3MubGluZS50b1N0cmluZygpLmxlbmd0aCwgJyAnKTtcbiAgICAgIHZhciBsaW5lID0gc3JjW3MubGluZSAtIDFdO1xuICAgICAgdmFyIGxhc3QgPSBzLmxpbmUgPT09IGUubGluZSA/IGUuY29sdW1uIDogbGluZS5sZW5ndGggKyAxO1xuICAgICAgdmFyIGhhdExlbiA9IChsYXN0IC0gcy5jb2x1bW4pIHx8IDE7XG4gICAgICBzdHIgKz0gXCJcXG4gLS0+IFwiICsgbG9jICsgXCJcXG5cIlxuICAgICAgICAgICsgZmlsbGVyICsgXCIgfFxcblwiXG4gICAgICAgICAgKyBvZmZzZXRfcy5saW5lICsgXCIgfCBcIiArIGxpbmUgKyBcIlxcblwiXG4gICAgICAgICAgKyBmaWxsZXIgKyBcIiB8IFwiICsgcGVnJHBhZEVuZChcIlwiLCBzLmNvbHVtbiAtIDEsICcgJylcbiAgICAgICAgICArIHBlZyRwYWRFbmQoXCJcIiwgaGF0TGVuLCBcIl5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSBcIlxcbiBhdCBcIiArIGxvYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbnBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQpIHtcbiAgdmFyIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOUyA9IHtcbiAgICBsaXRlcmFsOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgcmV0dXJuIFwiXFxcIlwiICsgbGl0ZXJhbEVzY2FwZShleHBlY3RhdGlvbi50ZXh0KSArIFwiXFxcIlwiO1xuICAgIH0sXG5cbiAgICBjbGFzczogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgIHZhciBlc2NhcGVkUGFydHMgPSBleHBlY3RhdGlvbi5wYXJ0cy5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXJ0KVxuICAgICAgICAgID8gY2xhc3NFc2NhcGUocGFydFswXSkgKyBcIi1cIiArIGNsYXNzRXNjYXBlKHBhcnRbMV0pXG4gICAgICAgICAgOiBjbGFzc0VzY2FwZShwYXJ0KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gXCJbXCIgKyAoZXhwZWN0YXRpb24uaW52ZXJ0ZWQgPyBcIl5cIiA6IFwiXCIpICsgZXNjYXBlZFBhcnRzLmpvaW4oXCJcIikgKyBcIl1cIjtcbiAgICB9LFxuXG4gICAgYW55OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcImFueSBjaGFyYWN0ZXJcIjtcbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcImVuZCBvZiBpbnB1dFwiO1xuICAgIH0sXG5cbiAgICBvdGhlcjogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgIHJldHVybiBleHBlY3RhdGlvbi5kZXNjcmlwdGlvbjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaGV4KGNoKSB7XG4gICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXRlcmFsRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKVxuICAgICAgLnJlcGxhY2UoL1wiL2csICBcIlxcXFxcXFwiXCIpXG4gICAgICAucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIilcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXG4gICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIilcbiAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csICAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiBcIlxcXFx4MFwiICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuIFwiXFxcXHhcIiAgKyBoZXgoY2gpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKVxuICAgICAgLnJlcGxhY2UoL1xcXS9nLCBcIlxcXFxdXCIpXG4gICAgICAucmVwbGFjZSgvXFxeL2csIFwiXFxcXF5cIilcbiAgICAgIC5yZXBsYWNlKC8tL2csICBcIlxcXFwtXCIpXG4gICAgICAucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIilcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXG4gICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIilcbiAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csICAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiBcIlxcXFx4MFwiICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuIFwiXFxcXHhcIiAgKyBoZXgoY2gpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0YXRpb24oZXhwZWN0YXRpb24pIHtcbiAgICByZXR1cm4gREVTQ1JJQkVfRVhQRUNUQVRJT05fRk5TW2V4cGVjdGF0aW9uLnR5cGVdKGV4cGVjdGF0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICB2YXIgZGVzY3JpcHRpb25zID0gZXhwZWN0ZWQubWFwKGRlc2NyaWJlRXhwZWN0YXRpb24pO1xuICAgIHZhciBpLCBqO1xuXG4gICAgZGVzY3JpcHRpb25zLnNvcnQoKTtcblxuICAgIGlmIChkZXNjcmlwdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZXNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uc1tpIC0gMV0gIT09IGRlc2NyaXB0aW9uc1tpXSkge1xuICAgICAgICAgIGRlc2NyaXB0aW9uc1tqXSA9IGRlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlc2NyaXB0aW9ucy5sZW5ndGggPSBqO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGVzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zWzBdO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF0gKyBcIiBvciBcIiArIGRlc2NyaXB0aW9uc1sxXTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9ucy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgKyBcIiwgb3IgXCJcbiAgICAgICAgICArIGRlc2NyaXB0aW9uc1tkZXNjcmlwdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzY3JpYmVGb3VuZChmb3VuZCkge1xuICAgIHJldHVybiBmb3VuZCA/IFwiXFxcIlwiICsgbGl0ZXJhbEVzY2FwZShmb3VuZCkgKyBcIlxcXCJcIiA6IFwiZW5kIG9mIGlucHV0XCI7XG4gIH1cblxuICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQpICsgXCIgYnV0IFwiICsgZGVzY3JpYmVGb3VuZChmb3VuZCkgKyBcIiBmb3VuZC5cIjtcbn07XG5cbmZ1bmN0aW9uIHBlZyRwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucyA6IHt9O1xuXG4gIHZhciBwZWckRkFJTEVEID0ge307XG4gIHZhciBwZWckc291cmNlID0gb3B0aW9ucy5ncmFtbWFyU291cmNlO1xuXG4gIHZhciBwZWckc3RhcnRSdWxlRnVuY3Rpb25zID0geyBwZ246IHBlZyRwYXJzZXBnbiB9O1xuICB2YXIgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHBhcnNlcGduO1xuXG4gIHZhciBwZWckYzAgPSBcIltcIjtcbiAgdmFyIHBlZyRjMSA9IFwiXFxcIlwiO1xuICB2YXIgcGVnJGMyID0gXCJdXCI7XG4gIHZhciBwZWckYzMgPSBcIi5cIjtcbiAgdmFyIHBlZyRjNCA9IFwiTy1PLU9cIjtcbiAgdmFyIHBlZyRjNSA9IFwiTy1PXCI7XG4gIHZhciBwZWckYzYgPSBcIjAtMC0wXCI7XG4gIHZhciBwZWckYzcgPSBcIjAtMFwiO1xuICB2YXIgcGVnJGM4ID0gXCIkXCI7XG4gIHZhciBwZWckYzkgPSBcIntcIjtcbiAgdmFyIHBlZyRjMTAgPSBcIn1cIjtcbiAgdmFyIHBlZyRjMTEgPSBcIjtcIjtcbiAgdmFyIHBlZyRjMTIgPSBcIihcIjtcbiAgdmFyIHBlZyRjMTMgPSBcIilcIjtcbiAgdmFyIHBlZyRjMTQgPSBcIjEtMFwiO1xuICB2YXIgcGVnJGMxNSA9IFwiMC0xXCI7XG4gIHZhciBwZWckYzE2ID0gXCIxLzItMS8yXCI7XG4gIHZhciBwZWckYzE3ID0gXCIqXCI7XG5cbiAgdmFyIHBlZyRyMCA9IC9eW2EtekEtWl0vO1xuICB2YXIgcGVnJHIxID0gL15bXlwiXS87XG4gIHZhciBwZWckcjIgPSAvXlswLTldLztcbiAgdmFyIHBlZyRyMyA9IC9eWy5dLztcbiAgdmFyIHBlZyRyNCA9IC9eW2EtekEtWjEtOFxcLT1dLztcbiAgdmFyIHBlZyRyNSA9IC9eWysjXS87XG4gIHZhciBwZWckcjYgPSAvXlshP10vO1xuICB2YXIgcGVnJHI3ID0gL15bXn1dLztcbiAgdmFyIHBlZyRyOCA9IC9eW15cXHJcXG5dLztcbiAgdmFyIHBlZyRyOSA9IC9eWyBcXHRcXHJcXG5dLztcblxuICB2YXIgcGVnJGUwID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ0YWcgcGFpclwiKTtcbiAgdmFyIHBlZyRlMSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJbXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJcXFwiXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJdXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlNCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwidGFnIG5hbWVcIik7XG4gIHZhciBwZWckZTUgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdXSwgZmFsc2UsIGZhbHNlKTtcbiAgdmFyIHBlZyRlNiA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwidGFnIHZhbHVlXCIpO1xuICB2YXIgcGVnJGU3ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiXFxcIlwiXSwgdHJ1ZSwgZmFsc2UpO1xuICB2YXIgcGVnJGU4ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJtb3ZlIG51bWJlclwiKTtcbiAgdmFyIHBlZyRlOSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIwXCIsIFwiOVwiXV0sIGZhbHNlLCBmYWxzZSk7XG4gIHZhciBwZWckZTEwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi5cIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUxMSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIi5cIl0sIGZhbHNlLCBmYWxzZSk7XG4gIHZhciBwZWckZTEyID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJzdGFuZGFyZCBhbGdlYnJhaWMgbm90YXRpb25cIik7XG4gIHZhciBwZWckZTEzID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIk8tTy1PXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMTQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiTy1PXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMTUgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMC0wLTBcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUxNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIwLTBcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUxNyA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFtcIjFcIiwgXCI4XCJdLCBcIi1cIiwgXCI9XCJdLCBmYWxzZSwgZmFsc2UpO1xuICB2YXIgcGVnJGUxOCA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIitcIiwgXCIjXCJdLCBmYWxzZSwgZmFsc2UpO1xuICB2YXIgcGVnJGUxOSA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwic3VmZml4IGFubm90YXRpb25cIik7XG4gIHZhciBwZWckZTIwID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiIVwiLCBcIj9cIl0sIGZhbHNlLCBmYWxzZSk7XG4gIHZhciBwZWckZTIxID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJOQUdcIik7XG4gIHZhciBwZWckZTIyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiRcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUyMyA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiYnJhY2UgY29tbWVudFwiKTtcbiAgdmFyIHBlZyRlMjQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwie1wiLCBmYWxzZSk7XG4gIHZhciBwZWckZTI1ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wifVwiXSwgdHJ1ZSwgZmFsc2UpO1xuICB2YXIgcGVnJGUyNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ9XCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMjcgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcInJlc3Qgb2YgbGluZSBjb21tZW50XCIpO1xuICB2YXIgcGVnJGUyOCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI7XCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMjkgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJcXHJcIiwgXCJcXG5cIl0sIHRydWUsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMzAgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcInZhcmlhdGlvblwiKTtcbiAgdmFyIHBlZyRlMzEgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKFwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTMyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIilcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUzMyA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiZ2FtZSB0ZXJtaW5hdGlvbiBtYXJrZXJcIik7XG4gIHZhciBwZWckZTM0ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjEtMFwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTM1ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjAtMVwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTM2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjEvMi0xLzJcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUzNyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIqXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlMzggPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcIndoaXRlc3BhY2VcIik7XG4gIHZhciBwZWckZTM5ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiIFwiLCBcIlxcdFwiLCBcIlxcclwiLCBcIlxcblwiXSwgZmFsc2UsIGZhbHNlKTtcblxuICB2YXIgcGVnJGYwID0gZnVuY3Rpb24oaGVhZGVycywgZ2FtZSkgeyByZXR1cm4gcGduKGhlYWRlcnMsIGdhbWUpIH07XG4gIHZhciBwZWckZjEgPSBmdW5jdGlvbih0YWdQYWlycykgeyByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRhZ1BhaXJzKSB9O1xuICB2YXIgcGVnJGYyID0gZnVuY3Rpb24odGFnTmFtZSwgdGFnVmFsdWUpIHsgcmV0dXJuIFt0YWdOYW1lLCB0YWdWYWx1ZV0gfTtcbiAgdmFyIHBlZyRmMyA9IGZ1bmN0aW9uKHJvb3QsIG1hcmtlcikgeyByZXR1cm4geyByb290LCBtYXJrZXJ9IH07XG4gIHZhciBwZWckZjQgPSBmdW5jdGlvbihjb21tZW50LCBtb3ZlcykgeyByZXR1cm4gbGluZVRvVHJlZShyb290Tm9kZShjb21tZW50KSwgLi4ubW92ZXMuZmxhdCgpKSB9O1xuICB2YXIgcGVnJGY1ID0gZnVuY3Rpb24oc2FuLCBzdWZmaXgsIG5hZywgY29tbWVudCwgdmFyaWF0aW9ucykgeyByZXR1cm4gbm9kZShzYW4sIHN1ZmZpeCwgbmFnLCBjb21tZW50LCB2YXJpYXRpb25zKSB9O1xuICB2YXIgcGVnJGY2ID0gZnVuY3Rpb24obmFnKSB7IHJldHVybiBuYWcgfTtcbiAgdmFyIHBlZyRmNyA9IGZ1bmN0aW9uKGNvbW1lbnQpIHsgcmV0dXJuIGNvbW1lbnQucmVwbGFjZSgvW1xcclxcbl0rL2csIFwiIFwiKSB9O1xuICB2YXIgcGVnJGY4ID0gZnVuY3Rpb24oY29tbWVudCkgeyByZXR1cm4gY29tbWVudC50cmltKCkgfTtcbiAgdmFyIHBlZyRmOSA9IGZ1bmN0aW9uKGxpbmUpIHsgcmV0dXJuIGxpbmUgfTtcbiAgdmFyIHBlZyRmMTAgPSBmdW5jdGlvbihyZXN1bHQsIGNvbW1lbnQpIHsgcmV0dXJuIHsgcmVzdWx0LCBjb21tZW50IH0gfTtcbiAgdmFyIHBlZyRjdXJyUG9zID0gb3B0aW9ucy5wZWckY3VyclBvcyB8IDA7XG4gIHZhciBwZWckcG9zRGV0YWlsc0NhY2hlID0gW3sgbGluZTogMSwgY29sdW1uOiAxIH1dO1xuICB2YXIgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgdmFyIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBvcHRpb25zLnBlZyRtYXhGYWlsRXhwZWN0ZWQgfHwgW107XG4gIHZhciBwZWckc2lsZW50RmFpbHMgPSBvcHRpb25zLnBlZyRzaWxlbnRGYWlscyB8IDA7XG5cbiAgdmFyIHBlZyRyZXN1bHQ7XG5cbiAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlKSB7XG4gICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICB9XG5cbiAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dCwgaWdub3JlQ2FzZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwibGl0ZXJhbFwiLCB0ZXh0OiB0ZXh0LCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY2xhc3NFeHBlY3RhdGlvbihwYXJ0cywgaW52ZXJ0ZWQsIGlnbm9yZUNhc2UpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImNsYXNzXCIsIHBhcnRzOiBwYXJ0cywgaW52ZXJ0ZWQ6IGludmVydGVkLCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckZW5kRXhwZWN0YXRpb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlbmRcIiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJG90aGVyRXhwZWN0YXRpb24oZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgIHZhciBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdO1xuICAgIHZhciBwO1xuXG4gICAgaWYgKGRldGFpbHMpIHtcbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocG9zID49IHBlZyRwb3NEZXRhaWxzQ2FjaGUubGVuZ3RoKSB7XG4gICAgICAgIHAgPSBwZWckcG9zRGV0YWlsc0NhY2hlLmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwID0gcG9zO1xuICAgICAgICB3aGlsZSAoIXBlZyRwb3NEZXRhaWxzQ2FjaGVbLS1wXSkge31cbiAgICAgIH1cblxuICAgICAgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcF07XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBsaW5lOiBkZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogZGV0YWlscy5jb2x1bW5cbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChwIDwgcG9zKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHApID09PSAxMCkge1xuICAgICAgICAgIGRldGFpbHMubGluZSsrO1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbisrO1xuICAgICAgICB9XG5cbiAgICAgICAgcCsrO1xuICAgICAgfVxuXG4gICAgICBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc10gPSBkZXRhaWxzO1xuXG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY29tcHV0ZUxvY2F0aW9uKHN0YXJ0UG9zLCBlbmRQb3MsIG9mZnNldCkge1xuICAgIHZhciBzdGFydFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoc3RhcnRQb3MpO1xuICAgIHZhciBlbmRQb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKGVuZFBvcyk7XG5cbiAgICB2YXIgcmVzID0ge1xuICAgICAgc291cmNlOiBwZWckc291cmNlLFxuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgb2Zmc2V0OiBzdGFydFBvcyxcbiAgICAgICAgbGluZTogc3RhcnRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogc3RhcnRQb3NEZXRhaWxzLmNvbHVtblxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBvZmZzZXQ6IGVuZFBvcyxcbiAgICAgICAgbGluZTogZW5kUG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGVuZFBvc0RldGFpbHMuY29sdW1uXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQpIHtcbiAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7XG4gICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgIH1cblxuICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoZXhwZWN0ZWQsIGZvdW5kLCBsb2NhdGlvbikge1xuICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKFxuICAgICAgcGVnJFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBmb3VuZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXBnbigpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2V0YWdQYWlyU2VjdGlvbigpO1xuICAgIHMyID0gcGVnJHBhcnNlbW92ZVRleHRTZWN0aW9uKCk7XG4gICAgczAgPSBwZWckZjAoczEsIHMyKTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXRhZ1BhaXJTZWN0aW9uKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIHMyID0gcGVnJHBhcnNldGFnUGFpcigpO1xuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBzMiA9IHBlZyRwYXJzZXRhZ1BhaXIoKTtcbiAgICB9XG4gICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgczAgPSBwZWckZjEoczEpO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldGFnUGFpcigpIHtcbiAgICB2YXIgczAsIHMyLCBzNCwgczYsIHM3LCBzOCwgczEwO1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBwZWckcGFyc2VfKCk7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgczIgPSBwZWckYzA7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMSk7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBwZWckcGFyc2VfKCk7XG4gICAgICBzNCA9IHBlZyRwYXJzZXRhZ05hbWUoKTtcbiAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcGFyc2VfKCk7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICBzNiA9IHBlZyRjMTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNyA9IHBlZyRwYXJzZXRhZ1ZhbHVlKCk7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xuICAgICAgICAgICAgczggPSBwZWckYzE7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzOCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMik7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7XG4gICAgICAgICAgICAgIHMxMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMxMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMxMCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRmMihzNCwgczcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUwKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXRhZ05hbWUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgIGlmIChwZWckcjAudGVzdChzMikpIHtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU1KTsgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBpZiAocGVnJHIwLnRlc3QoczIpKSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTUpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gaW5wdXQuc3Vic3RyaW5nKHMwLCBwZWckY3VyclBvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gczE7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTQpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldGFnVmFsdWUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgIGlmIChwZWckcjEudGVzdChzMikpIHtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU3KTsgfVxuICAgIH1cbiAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxLnB1c2goczIpO1xuICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgaWYgKHBlZyRyMS50ZXN0KHMyKSkge1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlNyk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgczAgPSBpbnB1dC5zdWJzdHJpbmcoczAsIHBlZyRjdXJyUG9zKTtcbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTYpOyB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vtb3ZlVGV4dFNlY3Rpb24oKSB7XG4gICAgdmFyIHMwLCBzMSwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlbGluZSgpO1xuICAgIHBlZyRwYXJzZV8oKTtcbiAgICBzMyA9IHBlZyRwYXJzZWdhbWVUZXJtaW5hdGlvbk1hcmtlcigpO1xuICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczMgPSBudWxsO1xuICAgIH1cbiAgICBwZWckcGFyc2VfKCk7XG4gICAgczAgPSBwZWckZjMoczEsIHMzKTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWxpbmUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWNvbW1lbnQoKTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gbnVsbDtcbiAgICB9XG4gICAgczIgPSBbXTtcbiAgICBzMyA9IHBlZyRwYXJzZW1vdmUoKTtcbiAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyLnB1c2goczMpO1xuICAgICAgczMgPSBwZWckcGFyc2Vtb3ZlKCk7XG4gICAgfVxuICAgIHMwID0gcGVnJGY0KHMxLCBzMik7XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vtb3ZlKCkge1xuICAgIHZhciBzMCwgczQsIHM1LCBzNiwgczcsIHM4LCBzOSwgczEwO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBwZWckcGFyc2VfKCk7XG4gICAgcGVnJHBhcnNlbW92ZU51bWJlcigpO1xuICAgIHBlZyRwYXJzZV8oKTtcbiAgICBzNCA9IHBlZyRwYXJzZXNhbigpO1xuICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczUgPSBwZWckcGFyc2VzdWZmaXhBbm5vdGF0aW9uKCk7XG4gICAgICBpZiAoczUgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczUgPSBudWxsO1xuICAgICAgfVxuICAgICAgczYgPSBbXTtcbiAgICAgIHM3ID0gcGVnJHBhcnNlbmFnKCk7XG4gICAgICB3aGlsZSAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczYucHVzaChzNyk7XG4gICAgICAgIHM3ID0gcGVnJHBhcnNlbmFnKCk7XG4gICAgICB9XG4gICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIHM4ID0gcGVnJHBhcnNlY29tbWVudCgpO1xuICAgICAgaWYgKHM4ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHM4ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHM5ID0gW107XG4gICAgICBzMTAgPSBwZWckcGFyc2V2YXJpYXRpb24oKTtcbiAgICAgIHdoaWxlIChzMTAgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczkucHVzaChzMTApO1xuICAgICAgICBzMTAgPSBwZWckcGFyc2V2YXJpYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHMwID0gcGVnJGY1KHM0LCBzNSwgczYsIHM4LCBzOSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbW92ZU51bWJlcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgaWYgKHBlZyRyMi50ZXN0KHMyKSkge1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTkpOyB9XG4gICAgfVxuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHIyLnRlc3QoczIpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU5KTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ2KSB7XG4gICAgICBzMiA9IHBlZyRjMztcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxMCk7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIHM0ID0gW107XG4gICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHIzLnRlc3QoczUpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxMSk7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBpZiAocGVnJHIzLnRlc3QoczUpKSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTExKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzMSA9IFtzMSwgczIsIHMzLCBzNF07XG4gICAgICBzMCA9IHMxO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU4KTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXNhbigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM0KSB7XG4gICAgICBzMiA9IHBlZyRjNDtcbiAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxMyk7IH1cbiAgICB9XG4gICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAzKSA9PT0gcGVnJGM1KSB7XG4gICAgICAgIHMyID0gcGVnJGM1O1xuICAgICAgICBwZWckY3VyclBvcyArPSAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTQpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNikge1xuICAgICAgICAgIHMyID0gcGVnJGM2O1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxNSk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAzKSA9PT0gcGVnJGM3KSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRjNztcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxNik7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgaWYgKHBlZyRyMC50ZXN0KHMzKSkge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlNSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIGlmIChwZWckcjQudGVzdChzNSkpIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTcpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckcjQudGVzdChzNSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTE3KTsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczMgPSBbczMsIHM0XTtcbiAgICAgICAgICAgICAgICBzMiA9IHMzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczI7XG4gICAgICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgaWYgKHBlZyRyNS50ZXN0KHMzKSkge1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTgpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBudWxsO1xuICAgICAgfVxuICAgICAgczIgPSBbczIsIHMzXTtcbiAgICAgIHMxID0gczI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczE7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBpbnB1dC5zdWJzdHJpbmcoczAsIHBlZyRjdXJyUG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBzMTtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTIpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc3VmZml4QW5ub3RhdGlvbigpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgaWYgKHBlZyRyNi50ZXN0KHMyKSkge1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTIwKTsgfVxuICAgIH1cbiAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxLnB1c2goczIpO1xuICAgICAgaWYgKHMxLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgaWYgKHBlZyRyNi50ZXN0KHMyKSkge1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyMCk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoczEubGVuZ3RoIDwgMSkge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBzMTtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTkpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbmFnKCkge1xuICAgIHZhciBzMCwgczIsIHMzLCBzNCwgczU7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHBlZyRwYXJzZV8oKTtcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM2KSB7XG4gICAgICBzMiA9IHBlZyRjODtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyMik7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgczQgPSBbXTtcbiAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIGlmIChwZWckcjIudGVzdChzNSkpIHtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTkpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQucHVzaChzNSk7XG4gICAgICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIGlmIChwZWckcjIudGVzdChzNSkpIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU5KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gaW5wdXQuc3Vic3RyaW5nKHMzLCBwZWckY3VyclBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMyA9IHM0O1xuICAgICAgfVxuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGY2KHMzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjEpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlY29tbWVudCgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBzMCA9IHBlZyRwYXJzZWJyYWNlQ29tbWVudCgpO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckcGFyc2VyZXN0T2ZMaW5lQ29tbWVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWJyYWNlQ29tbWVudCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xuICAgICAgczEgPSBwZWckYzk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjQpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgIHMzID0gW107XG4gICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHI3LnRlc3QoczQpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyNSk7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBpZiAocGVnJHI3LnRlc3QoczQpKSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTI1KTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzMiA9IGlucHV0LnN1YnN0cmluZyhzMiwgcGVnJGN1cnJQb3MpO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjUpIHtcbiAgICAgICAgczMgPSBwZWckYzEwO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckZjcoczIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyMyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VyZXN0T2ZMaW5lQ29tbWVudCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU5KSB7XG4gICAgICBzMSA9IHBlZyRjMTE7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjgpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgIHMzID0gW107XG4gICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHI4LnRlc3QoczQpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyOSk7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBpZiAocGVnJHI4LnRlc3QoczQpKSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTI5KTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzMiA9IGlucHV0LnN1YnN0cmluZyhzMiwgcGVnJGN1cnJQb3MpO1xuICAgICAgczAgPSBwZWckZjgoczIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyNyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V2YXJpYXRpb24oKSB7XG4gICAgdmFyIHMwLCBzMiwgczMsIHM1O1xuXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBwZWckcGFyc2VfKCk7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MCkge1xuICAgICAgczIgPSBwZWckYzEyO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTMxKTsgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMzID0gcGVnJHBhcnNlbGluZSgpO1xuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRwYXJzZV8oKTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkge1xuICAgICAgICAgIHM1ID0gcGVnJGMxMztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckZjkoczMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTMwKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWdhbWVUZXJtaW5hdGlvbk1hcmtlcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMztcblxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMykgPT09IHBlZyRjMTQpIHtcbiAgICAgIHMxID0gcGVnJGMxNDtcbiAgICAgIHBlZyRjdXJyUG9zICs9IDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzNCk7IH1cbiAgICB9XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAzKSA9PT0gcGVnJGMxNSkge1xuICAgICAgICBzMSA9IHBlZyRjMTU7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzNSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA3KSA9PT0gcGVnJGMxNikge1xuICAgICAgICAgIHMxID0gcGVnJGMxNjtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzYpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Mikge1xuICAgICAgICAgICAgczEgPSBwZWckYzE3O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTM3KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRwYXJzZV8oKTtcbiAgICAgIHMzID0gcGVnJHBhcnNlY29tbWVudCgpO1xuICAgICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHMwID0gcGVnJGYxMChzMSwgczMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzMyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VfKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IFtdO1xuICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICBpZiAocGVnJHI5LnRlc3QoczEpKSB7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzkpOyB9XG4gICAgfVxuICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAucHVzaChzMSk7XG4gICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBpZiAocGVnJHI5LnRlc3QoczEpKSB7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzOSk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgczEgPSBwZWckRkFJTEVEO1xuICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzOCk7IH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICBpZiAob3B0aW9ucy5wZWckbGlicmFyeSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHtcbiAgICAgIHBlZyRyZXN1bHQsXG4gICAgICBwZWckY3VyclBvcyxcbiAgICAgIHBlZyRGQUlMRUQsXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLFxuICAgICAgcGVnJG1heEZhaWxQb3NcbiAgICB9KTtcbiAgfVxuICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHBlZyRmYWlsKHBlZyRlbmRFeHBlY3RhdGlvbigpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLFxuICAgICAgcGVnJG1heEZhaWxQb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocGVnJG1heEZhaWxQb3MpIDogbnVsbCxcbiAgICAgIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoXG4gICAgICAgID8gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MgKyAxKVxuICAgICAgICA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zKVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDI1LCBKZWZmIEhseXdhIChqaGx5d2FAZ21haWwuY29tKVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbmNvbnN0IE1BU0s2NCA9IDB4ZmZmZmZmZmZmZmZmZmZmZm47XG5mdW5jdGlvbiByb3RsKHgsIGspIHtcbiAgICByZXR1cm4gKCh4IDw8IGspIHwgKHggPj4gKDY0biAtIGspKSkgJiAweGZmZmZmZmZmZmZmZmZmZmZuO1xufVxuZnVuY3Rpb24gd3JhcHBpbmdNdWwoeCwgeSkge1xuICAgIHJldHVybiAoeCAqIHkpICYgTUFTSzY0O1xufVxuLy8geG9yb3NoaXJvMTI4KipcbmZ1bmN0aW9uIHhvcm9zaGlybzEyOChzdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBzMCA9IEJpZ0ludChzdGF0ZSAmIE1BU0s2NCk7XG4gICAgICAgIGxldCBzMSA9IEJpZ0ludCgoc3RhdGUgPj4gNjRuKSAmIE1BU0s2NCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHdyYXBwaW5nTXVsKHJvdGwod3JhcHBpbmdNdWwoczAsIDVuKSwgN24pLCA5bik7XG4gICAgICAgIHMxIF49IHMwO1xuICAgICAgICBzMCA9IChyb3RsKHMwLCAyNG4pIF4gczEgXiAoczEgPDwgMTZuKSkgJiBNQVNLNjQ7XG4gICAgICAgIHMxID0gcm90bChzMSwgMzduKTtcbiAgICAgICAgc3RhdGUgPSAoczEgPDwgNjRuKSB8IHMwO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5jb25zdCByYW5kID0geG9yb3NoaXJvMTI4KDB4YTE4N2ViMzljZGNhZWQ4ZjMxYzRiMzY1YjEwMmUwMWVuKTtcbmNvbnN0IFBJRUNFX0tFWVMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyIH0sICgpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IDYgfSwgKCkgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTI4IH0sICgpID0+IHJhbmQoKSkpKTtcbmNvbnN0IEVQX0tFWVMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA4IH0sICgpID0+IHJhbmQoKSk7XG5jb25zdCBDQVNUTElOR19LRVlTID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTYgfSwgKCkgPT4gcmFuZCgpKTtcbmNvbnN0IFNJREVfS0VZID0gcmFuZCgpO1xuY29uc3QgV0hJVEUgPSAndyc7XG5jb25zdCBCTEFDSyA9ICdiJztcbmNvbnN0IFBBV04gPSAncCc7XG5jb25zdCBLTklHSFQgPSAnbic7XG5jb25zdCBCSVNIT1AgPSAnYic7XG5jb25zdCBST09LID0gJ3InO1xuY29uc3QgUVVFRU4gPSAncSc7XG5jb25zdCBLSU5HID0gJ2snO1xuY29uc3QgREVGQVVMVF9QT1NJVElPTiA9ICdybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMSc7XG5jbGFzcyBNb3ZlIHtcbiAgICBjb2xvcjtcbiAgICBmcm9tO1xuICAgIHRvO1xuICAgIHBpZWNlO1xuICAgIGNhcHR1cmVkO1xuICAgIHByb21vdGlvbjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZpZWxkIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDIuMC4wLlxuICAgICAqIFBsZWFzZSB1c2UgbW92ZSBkZXNjcmlwdG9yIGZ1bmN0aW9ucyBpbnN0ZWFkOiBgaXNDYXB0dXJlYCwgYGlzUHJvbW90aW9uYCxcbiAgICAgKiBgaXNFblBhc3NhbnRgLCBgaXNLaW5nc2lkZUNhc3RsZWAsIGBpc1F1ZWVuc2lkZUNhc3RsZWAsIGBpc0Nhc3RsZWAsIGFuZFxuICAgICAqIGBpc0JpZ1Bhd25gXG4gICAgICovXG4gICAgZmxhZ3M7XG4gICAgc2FuO1xuICAgIGxhbjtcbiAgICBiZWZvcmU7XG4gICAgYWZ0ZXI7XG4gICAgY29uc3RydWN0b3IoY2hlc3MsIGludGVybmFsKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIHBpZWNlLCBmcm9tLCB0bywgZmxhZ3MsIGNhcHR1cmVkLCBwcm9tb3Rpb24gfSA9IGludGVybmFsO1xuICAgICAgICBjb25zdCBmcm9tQWxnZWJyYWljID0gYWxnZWJyYWljKGZyb20pO1xuICAgICAgICBjb25zdCB0b0FsZ2VicmFpYyA9IGFsZ2VicmFpYyh0byk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5waWVjZSA9IHBpZWNlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tQWxnZWJyYWljO1xuICAgICAgICB0aGlzLnRvID0gdG9BbGdlYnJhaWM7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEhBQ0s6IFRoZSBjaGVzc1snX21ldGhvZCddKCkgY2FsbHMgYmVsb3cgaW52b2tlIHByaXZhdGUgbWV0aG9kcyBpbiB0aGVcbiAgICAgICAgICogQ2hlc3MgY2xhc3MgdG8gZ2VuZXJhdGUgU0FOIGFuZCBGRU4uIEl0J3MgYSBiaXQgb2YgYSBoYWNrLCBidXQgbWFrZXMgdGhlXG4gICAgICAgICAqIGNvZGUgY2xlYW5lciBlbHNld2hlcmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNhbiA9IGNoZXNzWydfbW92ZVRvU2FuJ10oaW50ZXJuYWwsIGNoZXNzWydfbW92ZXMnXSh7IGxlZ2FsOiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5sYW4gPSBmcm9tQWxnZWJyYWljICsgdG9BbGdlYnJhaWM7XG4gICAgICAgIHRoaXMuYmVmb3JlID0gY2hlc3MuZmVuKCk7XG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBGRU4gZm9yIHRoZSAnYWZ0ZXInIGtleVxuICAgICAgICBjaGVzc1snX21ha2VNb3ZlJ10oaW50ZXJuYWwpO1xuICAgICAgICB0aGlzLmFmdGVyID0gY2hlc3MuZmVuKCk7XG4gICAgICAgIGNoZXNzWydfdW5kb01vdmUnXSgpO1xuICAgICAgICAvLyBCdWlsZCB0aGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbW92ZSBmbGFnc1xuICAgICAgICB0aGlzLmZsYWdzID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgZmxhZyBpbiBCSVRTKSB7XG4gICAgICAgICAgICBpZiAoQklUU1tmbGFnXSAmIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGFncyArPSBGTEFHU1tmbGFnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZWQgPSBjYXB0dXJlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbW90aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnByb21vdGlvbiA9IHByb21vdGlvbjtcbiAgICAgICAgICAgIHRoaXMubGFuICs9IHByb21vdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0NhcHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0NBUFRVUkUnXSkgPiAtMTtcbiAgICB9XG4gICAgaXNQcm9tb3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1BST01PVElPTiddKSA+IC0xO1xuICAgIH1cbiAgICBpc0VuUGFzc2FudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snRVBfQ0FQVFVSRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc0tpbmdzaWRlQ2FzdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFncy5pbmRleE9mKEZMQUdTWydLU0lERV9DQVNUTEUnXSkgPiAtMTtcbiAgICB9XG4gICAgaXNRdWVlbnNpZGVDYXN0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1FTSURFX0NBU1RMRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc0JpZ1Bhd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0JJR19QQVdOJ10pID4gLTE7XG4gICAgfVxufVxuY29uc3QgRU1QVFkgPSAtMTtcbmNvbnN0IEZMQUdTID0ge1xuICAgIE5PUk1BTDogJ24nLFxuICAgIENBUFRVUkU6ICdjJyxcbiAgICBCSUdfUEFXTjogJ2InLFxuICAgIEVQX0NBUFRVUkU6ICdlJyxcbiAgICBQUk9NT1RJT046ICdwJyxcbiAgICBLU0lERV9DQVNUTEU6ICdrJyxcbiAgICBRU0lERV9DQVNUTEU6ICdxJyxcbiAgICBOVUxMX01PVkU6ICctJyxcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNRVUFSRVMgPSBbXG4gICAgJ2E4JywgJ2I4JywgJ2M4JywgJ2Q4JywgJ2U4JywgJ2Y4JywgJ2c4JywgJ2g4JyxcbiAgICAnYTcnLCAnYjcnLCAnYzcnLCAnZDcnLCAnZTcnLCAnZjcnLCAnZzcnLCAnaDcnLFxuICAgICdhNicsICdiNicsICdjNicsICdkNicsICdlNicsICdmNicsICdnNicsICdoNicsXG4gICAgJ2E1JywgJ2I1JywgJ2M1JywgJ2Q1JywgJ2U1JywgJ2Y1JywgJ2c1JywgJ2g1JyxcbiAgICAnYTQnLCAnYjQnLCAnYzQnLCAnZDQnLCAnZTQnLCAnZjQnLCAnZzQnLCAnaDQnLFxuICAgICdhMycsICdiMycsICdjMycsICdkMycsICdlMycsICdmMycsICdnMycsICdoMycsXG4gICAgJ2EyJywgJ2IyJywgJ2MyJywgJ2QyJywgJ2UyJywgJ2YyJywgJ2cyJywgJ2gyJyxcbiAgICAnYTEnLCAnYjEnLCAnYzEnLCAnZDEnLCAnZTEnLCAnZjEnLCAnZzEnLCAnaDEnXG5dO1xuY29uc3QgQklUUyA9IHtcbiAgICBOT1JNQUw6IDEsXG4gICAgQ0FQVFVSRTogMixcbiAgICBCSUdfUEFXTjogNCxcbiAgICBFUF9DQVBUVVJFOiA4LFxuICAgIFBST01PVElPTjogMTYsXG4gICAgS1NJREVfQ0FTVExFOiAzMixcbiAgICBRU0lERV9DQVNUTEU6IDY0LFxuICAgIE5VTExfTU9WRTogMTI4LFxufTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuLy8gdGhlc2UgYXJlIHJlcXVpcmVkLCBhY2NvcmRpbmcgdG8gc3BlY1xuY29uc3QgU0VWRU5fVEFHX1JPU1RFUiA9IHtcbiAgICBFdmVudDogJz8nLFxuICAgIFNpdGU6ICc/JyxcbiAgICBEYXRlOiAnPz8/Py4/Py4/PycsXG4gICAgUm91bmQ6ICc/JyxcbiAgICBXaGl0ZTogJz8nLFxuICAgIEJsYWNrOiAnPycsXG4gICAgUmVzdWx0OiAnKicsXG59O1xuLyoqXG4gKiBUaGVzZSBudWxscyBhcmUgcGxhY2Vob2xkZXJzIHRvIGZpeCB0aGUgb3JkZXIgb2YgdGFncyAoYXMgdGhleSBhcHBlYXIgaW4gUEdOIHNwZWMpOyBudWxsIHZhbHVlcyB3aWxsIGJlXG4gKiBlbGltaW5hdGVkIGluIGdldEhlYWRlcnMoKVxuICovXG5jb25zdCBTVVBMRU1FTlRBTF9UQUdTID0ge1xuICAgIFdoaXRlVGl0bGU6IG51bGwsXG4gICAgQmxhY2tUaXRsZTogbnVsbCxcbiAgICBXaGl0ZUVsbzogbnVsbCxcbiAgICBCbGFja0VsbzogbnVsbCxcbiAgICBXaGl0ZVVTQ0Y6IG51bGwsXG4gICAgQmxhY2tVU0NGOiBudWxsLFxuICAgIFdoaXRlTkE6IG51bGwsXG4gICAgQmxhY2tOQTogbnVsbCxcbiAgICBXaGl0ZVR5cGU6IG51bGwsXG4gICAgQmxhY2tUeXBlOiBudWxsLFxuICAgIEV2ZW50RGF0ZTogbnVsbCxcbiAgICBFdmVudFNwb25zb3I6IG51bGwsXG4gICAgU2VjdGlvbjogbnVsbCxcbiAgICBTdGFnZTogbnVsbCxcbiAgICBCb2FyZDogbnVsbCxcbiAgICBPcGVuaW5nOiBudWxsLFxuICAgIFZhcmlhdGlvbjogbnVsbCxcbiAgICBTdWJWYXJpYXRpb246IG51bGwsXG4gICAgRUNPOiBudWxsLFxuICAgIE5JQzogbnVsbCxcbiAgICBUaW1lOiBudWxsLFxuICAgIFVUQ1RpbWU6IG51bGwsXG4gICAgVVRDRGF0ZTogbnVsbCxcbiAgICBUaW1lQ29udHJvbDogbnVsbCxcbiAgICBTZXRVcDogbnVsbCxcbiAgICBGRU46IG51bGwsXG4gICAgVGVybWluYXRpb246IG51bGwsXG4gICAgQW5ub3RhdG9yOiBudWxsLFxuICAgIE1vZGU6IG51bGwsXG4gICAgUGx5Q291bnQ6IG51bGwsXG59O1xuY29uc3QgSEVBREVSX1RFTVBMQVRFID0ge1xuICAgIC4uLlNFVkVOX1RBR19ST1NURVIsXG4gICAgLi4uU1VQTEVNRU5UQUxfVEFHUyxcbn07XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuLypcbiAqIE5PVEVTIEFCT1VUIDB4ODggTU9WRSBHRU5FUkFUSU9OIEFMR09SSVRITVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vamhseXdhL2NoZXNzLmpzL2lzc3Vlcy8yMzBcbiAqXG4gKiBBIGxvdCBvZiBwZW9wbGUgYXJlIGNvbmZ1c2VkIHdoZW4gdGhleSBmaXJzdCBzZWUgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gKiBvZiBjaGVzcy5qcy4gSXQgdXNlcyB0aGUgMHg4OCBNb3ZlIEdlbmVyYXRpb24gQWxnb3JpdGhtIHdoaWNoIGludGVybmFsbHlcbiAqIHN0b3JlcyB0aGUgYm9hcmQgYXMgYW4gOHgxNiBhcnJheS4gVGhpcyBpcyBwdXJlbHkgZm9yIGVmZmljaWVuY3kgYnV0IGhhcyBhXG4gKiBjb3VwbGUgb2YgaW50ZXJlc3RpbmcgYmVuZWZpdHM6XG4gKlxuICogMS4gMHg4OCBvZmZlcnMgYSB2ZXJ5IGluZXhwZW5zaXZlIFwib2ZmIHRoZSBib2FyZFwiIGNoZWNrLiBCaXR3aXNlIEFORCAoJikgYW55XG4gKiAgICBzcXVhcmUgd2l0aCAweDg4LCBpZiB0aGUgcmVzdWx0IGlzIG5vbi16ZXJvIHRoZW4gdGhlIHNxdWFyZSBpcyBvZmYgdGhlXG4gKiAgICBib2FyZC4gRm9yIGV4YW1wbGUsIGFzc3VtaW5nIGEga25pZ2h0IHNxdWFyZSBBOCAoMCBpbiAweDg4IG5vdGF0aW9uKSxcbiAqICAgIHRoZXJlIGFyZSA4IHBvc3NpYmxlIGRpcmVjdGlvbnMgaW4gd2hpY2ggdGhlIGtuaWdodCBjYW4gbW92ZS4gVGhlc2VcbiAqICAgIGRpcmVjdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoZSA4eDE2IGJvYXJkIGFuZCBhcmUgc3RvcmVkIGluIHRoZVxuICogICAgUElFQ0VfT0ZGU0VUUyBtYXAuIE9uZSBwb3NzaWJsZSBtb3ZlIGlzIEE4IC0gMTggKHVwIG9uZSBzcXVhcmUsIGFuZCB0d29cbiAqICAgIHNxdWFyZXMgdG8gdGhlIGxlZnQgLSB3aGljaCBpcyBvZmYgdGhlIGJvYXJkKS4gMCAtIDE4ID0gLTE4ICYgMHg4OCA9IDB4ODhcbiAqICAgIChiZWNhdXNlIG9mIHR3by1jb21wbGVtZW50IHJlcHJlc2VudGF0aW9uIG9mIC0xOCkuIFRoZSBub24temVybyByZXN1bHRcbiAqICAgIG1lYW5zIHRoZSBzcXVhcmUgaXMgb2ZmIHRoZSBib2FyZCBhbmQgdGhlIG1vdmUgaXMgaWxsZWdhbC4gVGFrZSB0aGVcbiAqICAgIG9wcG9zaXRlIG1vdmUgKGZyb20gQTggdG8gQzcpLCAwICsgMTggPSAxOCAmIDB4ODggPSAwLiBBIHJlc3VsdCBvZiB6ZXJvXG4gKiAgICBtZWFucyB0aGUgc3F1YXJlIGlzIG9uIHRoZSBib2FyZC5cbiAqXG4gKiAyLiBUaGUgcmVsYXRpdmUgZGlzdGFuY2UgKG9yIGRpZmZlcmVuY2UpIGJldHdlZW4gdHdvIHNxdWFyZXMgb24gYSA4eDE2IGJvYXJkXG4gKiAgICBpcyB1bmlxdWUgYW5kIGNhbiBiZSB1c2VkIHRvIGluZXhwZW5zaXZlbHkgZGV0ZXJtaW5lIGlmIGEgcGllY2Ugb24gYVxuICogICAgc3F1YXJlIGNhbiBhdHRhY2sgYW55IG90aGVyIGFyYml0cmFyeSBzcXVhcmUuIEZvciBleGFtcGxlLCBsZXQncyBzZWUgaWYgYVxuICogICAgcGF3biBvbiBFNyBjYW4gYXR0YWNrIEUyLiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIEU3ICgyMCkgLSBFMiAoMTAwKSBpc1xuICogICAgLTgwLiBXZSBhZGQgMTE5IHRvIG1ha2UgdGhlIEFUVEFDS1MgYXJyYXkgaW5kZXggbm9uLW5lZ2F0aXZlIChiZWNhdXNlIHRoZVxuICogICAgd29yc3QgY2FzZSBkaWZmZXJlbmNlIGlzIEE4IC0gSDEgPSAtMTE5KS4gVGhlIEFUVEFDS1MgYXJyYXkgY29udGFpbnMgYVxuICogICAgYml0bWFzayBvZiBwaWVjZXMgdGhhdCBjYW4gYXR0YWNrIGZyb20gdGhhdCBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uLlxuICogICAgQVRUQUNLU1stODAgKyAxMTk9MzldIGdpdmVzIHVzIDI0IG9yIDBiMTEwMDAgaW4gYmluYXJ5LiBMb29rIGF0IHRoZVxuICogICAgUElFQ0VfTUFTS1MgbWFwIHRvIGRldGVybWluZSB0aGUgbWFzayBmb3IgYSBnaXZlbiBwaWVjZSB0eXBlLiBJbiBvdXIgcGF3blxuICogICAgZXhhbXBsZSwgd2Ugd291bGQgY2hlY2sgdG8gc2VlIGlmIDI0ICYgMHgxIGlzIG5vbi16ZXJvLCB3aGljaCBpdCBpc1xuICogICAgbm90LiBTbywgbmF0dXJhbGx5LCBhIHBhd24gb24gRTcgY2FuJ3QgYXR0YWNrIGEgcGllY2Ugb24gRTIuIEhvd2V2ZXIsIGFcbiAqICAgIHJvb2sgY2FuIHNpbmNlIDI0ICYgMHg4IGlzIG5vbi16ZXJvLiBUaGUgb25seSB0aGluZyBsZWZ0IHRvIGNoZWNrIGlzIHRoYXRcbiAqICAgIHRoZXJlIGFyZSBubyBibG9ja2luZyBwaWVjZXMgYmV0d2VlbiBFNyBhbmQgRTIuIFRoYXQncyB3aGVyZSB0aGUgUkFZU1xuICogICAgYXJyYXkgY29tZXMgaW4uIEl0IHByb3ZpZGVzIGFuIG9mZnNldCAoaW4gdGhpcyBjYXNlIDE2KSB0byBhZGQgdG8gRTcgKDIwKVxuICogICAgdG8gY2hlY2sgZm9yIGJsb2NraW5nIHBpZWNlcy4gRTcgKDIwKSArIDE2ID0gRTYgKDM2KSArIDE2ID0gRTUgKDUyKSBldGMuXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5jb25zdCBPeDg4ID0ge1xuICAgIGE4OiAwLCBiODogMSwgYzg6IDIsIGQ4OiAzLCBlODogNCwgZjg6IDUsIGc4OiA2LCBoODogNyxcbiAgICBhNzogMTYsIGI3OiAxNywgYzc6IDE4LCBkNzogMTksIGU3OiAyMCwgZjc6IDIxLCBnNzogMjIsIGg3OiAyMyxcbiAgICBhNjogMzIsIGI2OiAzMywgYzY6IDM0LCBkNjogMzUsIGU2OiAzNiwgZjY6IDM3LCBnNjogMzgsIGg2OiAzOSxcbiAgICBhNTogNDgsIGI1OiA0OSwgYzU6IDUwLCBkNTogNTEsIGU1OiA1MiwgZjU6IDUzLCBnNTogNTQsIGg1OiA1NSxcbiAgICBhNDogNjQsIGI0OiA2NSwgYzQ6IDY2LCBkNDogNjcsIGU0OiA2OCwgZjQ6IDY5LCBnNDogNzAsIGg0OiA3MSxcbiAgICBhMzogODAsIGIzOiA4MSwgYzM6IDgyLCBkMzogODMsIGUzOiA4NCwgZjM6IDg1LCBnMzogODYsIGgzOiA4NyxcbiAgICBhMjogOTYsIGIyOiA5NywgYzI6IDk4LCBkMjogOTksIGUyOiAxMDAsIGYyOiAxMDEsIGcyOiAxMDIsIGgyOiAxMDMsXG4gICAgYTE6IDExMiwgYjE6IDExMywgYzE6IDExNCwgZDE6IDExNSwgZTE6IDExNiwgZjE6IDExNywgZzE6IDExOCwgaDE6IDExOVxufTtcbmNvbnN0IFBBV05fT0ZGU0VUUyA9IHtcbiAgICBiOiBbMTYsIDMyLCAxNywgMTVdLFxuICAgIHc6IFstMTYsIC0zMiwgLTE3LCAtMTVdLFxufTtcbmNvbnN0IFBJRUNFX09GRlNFVFMgPSB7XG4gICAgbjogWy0xOCwgLTMzLCAtMzEsIC0xNCwgMTgsIDMzLCAzMSwgMTRdLFxuICAgIGI6IFstMTcsIC0xNSwgMTcsIDE1XSxcbiAgICByOiBbLTE2LCAxLCAxNiwgLTFdLFxuICAgIHE6IFstMTcsIC0xNiwgLTE1LCAxLCAxNywgMTYsIDE1LCAtMV0sXG4gICAgazogWy0xNywgLTE2LCAtMTUsIDEsIDE3LCAxNiwgMTUsIC0xXSxcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEFUVEFDS1MgPSBbXG4gICAgMjAsIDAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAwLCAyMCwgMCxcbiAgICAwLCAyMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDIwLCAwLCAwLFxuICAgIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMjAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMjQsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDIwLCAyLCAyNCwgMiwgMjAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMiwgNTMsIDU2LCA1MywgMiwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCA1NiwgMCwgNTYsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMiwgNTMsIDU2LCA1MywgMiwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyMCwgMiwgMjQsIDIsIDIwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDIwLCAwLCAwLCAyNCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMjAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLFxuICAgIDAsIDIwLCAwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsXG4gICAgMjAsIDAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAwLCAyMFxuXTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgUkFZUyA9IFtcbiAgICAxNywgMCwgMCwgMCwgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDAsIDAsIDAsIDE1LCAwLFxuICAgIDAsIDE3LCAwLCAwLCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMCwgMCwgMTUsIDAsIDAsXG4gICAgMCwgMCwgMTcsIDAsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAwLCAxNSwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAxNywgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDE1LCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDE3LCAwLCAwLCAxNiwgMCwgMCwgMTUsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMTcsIDAsIDE2LCAwLCAxNSwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAxNywgMTYsIDE1LCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIC0xNSwgLTE2LCAtMTcsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgLTE1LCAwLCAtMTYsIDAsIC0xNywgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAtMTUsIDAsIDAsIC0xNiwgMCwgMCwgLTE3LCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIC0xNSwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAtMTcsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgLTE1LCAwLCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIDAsIC0xNywgMCwgMCwgMCxcbiAgICAwLCAtMTUsIDAsIDAsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgMCwgMCwgLTE3LCAwLCAwLFxuICAgIC0xNSwgMCwgMCwgMCwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAwLCAwLCAwLCAtMTdcbl07XG5jb25zdCBQSUVDRV9NQVNLUyA9IHsgcDogMHgxLCBuOiAweDIsIGI6IDB4NCwgcjogMHg4LCBxOiAweDEwLCBrOiAweDIwIH07XG5jb25zdCBTWU1CT0xTID0gJ3BuYnJxa1BOQlJRSyc7XG5jb25zdCBQUk9NT1RJT05TID0gW0tOSUdIVCwgQklTSE9QLCBST09LLCBRVUVFTl07XG5jb25zdCBSQU5LXzEgPSA3O1xuY29uc3QgUkFOS18yID0gNjtcbi8qXG4gKiBjb25zdCBSQU5LXzMgPSA1XG4gKiBjb25zdCBSQU5LXzQgPSA0XG4gKiBjb25zdCBSQU5LXzUgPSAzXG4gKiBjb25zdCBSQU5LXzYgPSAyXG4gKi9cbmNvbnN0IFJBTktfNyA9IDE7XG5jb25zdCBSQU5LXzggPSAwO1xuY29uc3QgU0lERVMgPSB7XG4gICAgW0tJTkddOiBCSVRTLktTSURFX0NBU1RMRSxcbiAgICBbUVVFRU5dOiBCSVRTLlFTSURFX0NBU1RMRSxcbn07XG5jb25zdCBST09LUyA9IHtcbiAgICB3OiBbXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4LmExLCBmbGFnOiBCSVRTLlFTSURFX0NBU1RMRSB9LFxuICAgICAgICB7IHNxdWFyZTogT3g4OC5oMSwgZmxhZzogQklUUy5LU0lERV9DQVNUTEUgfSxcbiAgICBdLFxuICAgIGI6IFtcbiAgICAgICAgeyBzcXVhcmU6IE94ODguYTgsIGZsYWc6IEJJVFMuUVNJREVfQ0FTVExFIH0sXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4Lmg4LCBmbGFnOiBCSVRTLktTSURFX0NBU1RMRSB9LFxuICAgIF0sXG59O1xuY29uc3QgU0VDT05EX1JBTksgPSB7IGI6IFJBTktfNywgdzogUkFOS18yIH07XG5jb25zdCBTQU5fTlVMTE1PVkUgPSAnLS0nO1xuLy8gRXh0cmFjdHMgdGhlIHplcm8tYmFzZWQgcmFuayBvZiBhbiAweDg4IHNxdWFyZS5cbmZ1bmN0aW9uIHJhbmsoc3F1YXJlKSB7XG4gICAgcmV0dXJuIHNxdWFyZSA+PiA0O1xufVxuLy8gRXh0cmFjdHMgdGhlIHplcm8tYmFzZWQgZmlsZSBvZiBhbiAweDg4IHNxdWFyZS5cbmZ1bmN0aW9uIGZpbGUoc3F1YXJlKSB7XG4gICAgcmV0dXJuIHNxdWFyZSAmIDB4Zjtcbn1cbmZ1bmN0aW9uIGlzRGlnaXQoYykge1xuICAgIHJldHVybiAnMDEyMzQ1Njc4OScuaW5kZXhPZihjKSAhPT0gLTE7XG59XG4vLyBDb252ZXJ0cyBhIDB4ODggc3F1YXJlIHRvIGFsZ2VicmFpYyBub3RhdGlvbi5cbmZ1bmN0aW9uIGFsZ2VicmFpYyhzcXVhcmUpIHtcbiAgICBjb25zdCBmID0gZmlsZShzcXVhcmUpO1xuICAgIGNvbnN0IHIgPSByYW5rKHNxdWFyZSk7XG4gICAgcmV0dXJuICgnYWJjZGVmZ2gnLnN1YnN0cmluZyhmLCBmICsgMSkgK1xuICAgICAgICAnODc2NTQzMjEnLnN1YnN0cmluZyhyLCByICsgMSkpO1xufVxuZnVuY3Rpb24gc3dhcENvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yID09PSBXSElURSA/IEJMQUNLIDogV0hJVEU7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUZlbihmZW4pIHtcbiAgICAvLyAxc3QgY3JpdGVyaW9uOiA2IHNwYWNlLXNlcGVyYXRlZCBmaWVsZHM/XG4gICAgY29uc3QgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG11c3QgY29udGFpbiBzaXggc3BhY2UtZGVsaW1pdGVkIGZpZWxkcycsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDJuZCBjcml0ZXJpb246IG1vdmUgbnVtYmVyIGZpZWxkIGlzIGEgaW50ZWdlciB2YWx1ZSA+IDA/XG4gICAgY29uc3QgbW92ZU51bWJlciA9IHBhcnNlSW50KHRva2Vuc1s1XSwgMTApO1xuICAgIGlmIChpc05hTihtb3ZlTnVtYmVyKSB8fCBtb3ZlTnVtYmVyIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG1vdmUgbnVtYmVyIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gM3JkIGNyaXRlcmlvbjogaGFsZiBtb3ZlIGNvdW50ZXIgaXMgYW4gaW50ZWdlciA+PSAwP1xuICAgIGNvbnN0IGhhbGZNb3ZlcyA9IHBhcnNlSW50KHRva2Vuc1s0XSwgMTApO1xuICAgIGlmIChpc05hTihoYWxmTW92ZXMpIHx8IGhhbGZNb3ZlcyA8IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IGhhbGYgbW92ZSBjb3VudGVyIG51bWJlciBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyA0dGggY3JpdGVyaW9uOiA0dGggZmllbGQgaXMgYSB2YWxpZCBlLnAuLXN0cmluZz9cbiAgICBpZiAoIS9eKC18W2FiY2RlZmdoXVszNl0pJC8udGVzdCh0b2tlbnNbM10pKSB7XG4gICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIEZFTjogZW4tcGFzc2FudCBzcXVhcmUgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gNXRoIGNyaXRlcmlvbjogM3RoIGZpZWxkIGlzIGEgdmFsaWQgY2FzdGxlLXN0cmluZz9cbiAgICBpZiAoL1tea0txUS1dLy50ZXN0KHRva2Vuc1syXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBjYXN0bGluZyBhdmFpbGFiaWxpdHkgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gNnRoIGNyaXRlcmlvbjogMm5kIGZpZWxkIGlzIFwid1wiICh3aGl0ZSkgb3IgXCJiXCIgKGJsYWNrKT9cbiAgICBpZiAoIS9eKHd8YikkLy50ZXN0KHRva2Vuc1sxXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBzaWRlLXRvLW1vdmUgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gN3RoIGNyaXRlcmlvbjogMXN0IGZpZWxkIGNvbnRhaW5zIDggcm93cz9cbiAgICBjb25zdCByb3dzID0gdG9rZW5zWzBdLnNwbGl0KCcvJyk7XG4gICAgaWYgKHJvd3MubGVuZ3RoICE9PSA4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBkb2VzIG5vdCBjb250YWluIDggJy8nLWRlbGltaXRlZCByb3dzXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDh0aCBjcml0ZXJpb246IGV2ZXJ5IHJvdyBpcyB2YWxpZD9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHJpZ2h0IHN1bSBvZiBmaWVsZHMgQU5EIG5vdCB0d28gbnVtYmVycyBpbiBzdWNjZXNzaW9uXG4gICAgICAgIGxldCBzdW1GaWVsZHMgPSAwO1xuICAgICAgICBsZXQgcHJldmlvdXNXYXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzW2ldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAoaXNEaWdpdChyb3dzW2ldW2tdKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1dhc051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBpcyBpbnZhbGlkIChjb25zZWN1dGl2ZSBudW1iZXIpJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IHBhcnNlSW50KHJvd3NbaV1ba10sIDEwKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1dhc051bWJlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9eW3BybmJxa1BSTkJRS10kLy50ZXN0KHJvd3NbaV1ba10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKGludmFsaWQgcGllY2UpJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IDE7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNXYXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtRmllbGRzICE9PSA4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKHRvbyBtYW55IHNxdWFyZXMgaW4gcmFuayknLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA5dGggY3JpdGVyaW9uOiBpcyBlbi1wYXNzYW50IHNxdWFyZSBsZWdhbD9cbiAgICBpZiAoKHRva2Vuc1szXVsxXSA9PSAnMycgJiYgdG9rZW5zWzFdID09ICd3JykgfHxcbiAgICAgICAgKHRva2Vuc1szXVsxXSA9PSAnNicgJiYgdG9rZW5zWzFdID09ICdiJykpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBpbGxlZ2FsIGVuLXBhc3NhbnQgc3F1YXJlJyB9O1xuICAgIH1cbiAgICAvLyAxMHRoIGNyaXRlcmlvbjogZG9lcyBjaGVzcyBwb3NpdGlvbiBjb250YWluIGV4YWN0IHR3byBraW5ncz9cbiAgICBjb25zdCBraW5ncyA9IFtcbiAgICAgICAgeyBjb2xvcjogJ3doaXRlJywgcmVnZXg6IC9LL2cgfSxcbiAgICAgICAgeyBjb2xvcjogJ2JsYWNrJywgcmVnZXg6IC9rL2cgfSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgeyBjb2xvciwgcmVnZXggfSBvZiBraW5ncykge1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QodG9rZW5zWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogYEludmFsaWQgRkVOOiBtaXNzaW5nICR7Y29sb3J9IGtpbmdgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0b2tlbnNbMF0ubWF0Y2gocmVnZXgpIHx8IFtdKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBgSW52YWxpZCBGRU46IHRvbyBtYW55ICR7Y29sb3J9IGtpbmdzYCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDExdGggY3JpdGVyaW9uOiBhcmUgYW55IHBhd25zIG9uIHRoZSBmaXJzdCBvciBlaWdodGggcm93cz9cbiAgICBpZiAoQXJyYXkuZnJvbShyb3dzWzBdICsgcm93c1s3XSkuc29tZSgoY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpID09PSAnUCcpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBzb21lIHBhd25zIGFyZSBvbiB0aGUgZWRnZSByb3dzJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb2s6IHRydWUgfTtcbn1cbi8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBhbWJpZ3VvdXMgbW92ZXNcbmZ1bmN0aW9uIGdldERpc2FtYmlndWF0b3IobW92ZSwgbW92ZXMpIHtcbiAgICBjb25zdCBmcm9tID0gbW92ZS5mcm9tO1xuICAgIGNvbnN0IHRvID0gbW92ZS50bztcbiAgICBjb25zdCBwaWVjZSA9IG1vdmUucGllY2U7XG4gICAgbGV0IGFtYmlndWl0aWVzID0gMDtcbiAgICBsZXQgc2FtZVJhbmsgPSAwO1xuICAgIGxldCBzYW1lRmlsZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFtYmlnRnJvbSA9IG1vdmVzW2ldLmZyb207XG4gICAgICAgIGNvbnN0IGFtYmlnVG8gPSBtb3Zlc1tpXS50bztcbiAgICAgICAgY29uc3QgYW1iaWdQaWVjZSA9IG1vdmVzW2ldLnBpZWNlO1xuICAgICAgICAvKlxuICAgICAgICAgKiBpZiBhIG1vdmUgb2YgdGhlIHNhbWUgcGllY2UgdHlwZSBlbmRzIG9uIHRoZSBzYW1lIHRvIHNxdWFyZSwgd2UnbGwgbmVlZFxuICAgICAgICAgKiB0byBhZGQgYSBkaXNhbWJpZ3VhdG9yIHRvIHRoZSBhbGdlYnJhaWMgbm90YXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwaWVjZSA9PT0gYW1iaWdQaWVjZSAmJiBmcm9tICE9PSBhbWJpZ0Zyb20gJiYgdG8gPT09IGFtYmlnVG8pIHtcbiAgICAgICAgICAgIGFtYmlndWl0aWVzKys7XG4gICAgICAgICAgICBpZiAocmFuayhmcm9tKSA9PT0gcmFuayhhbWJpZ0Zyb20pKSB7XG4gICAgICAgICAgICAgICAgc2FtZVJhbmsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxlKGZyb20pID09PSBmaWxlKGFtYmlnRnJvbSkpIHtcbiAgICAgICAgICAgICAgICBzYW1lRmlsZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbWJpZ3VpdGllcyA+IDApIHtcbiAgICAgICAgaWYgKHNhbWVSYW5rID4gMCAmJiBzYW1lRmlsZSA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpZiB0aGVyZSBleGlzdHMgYSBzaW1pbGFyIG1vdmluZyBwaWVjZSBvbiB0aGUgc2FtZSByYW5rIGFuZCBmaWxlIGFzXG4gICAgICAgICAgICAgKiB0aGUgbW92ZSBpbiBxdWVzdGlvbiwgdXNlIHRoZSBzcXVhcmUgYXMgdGhlIGRpc2FtYmlndWF0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGFsZ2VicmFpYyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzYW1lRmlsZSA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpZiB0aGUgbW92aW5nIHBpZWNlIHJlc3RzIG9uIHRoZSBzYW1lIGZpbGUsIHVzZSB0aGUgcmFuayBzeW1ib2wgYXMgdGhlXG4gICAgICAgICAgICAgKiBkaXNhbWJpZ3VhdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxzZSB1c2UgdGhlIGZpbGUgc3ltYm9sXG4gICAgICAgICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pLmNoYXJBdCgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBhZGRNb3ZlKG1vdmVzLCBjb2xvciwgZnJvbSwgdG8sIHBpZWNlLCBjYXB0dXJlZCA9IHVuZGVmaW5lZCwgZmxhZ3MgPSBCSVRTLk5PUk1BTCkge1xuICAgIGNvbnN0IHIgPSByYW5rKHRvKTtcbiAgICBpZiAocGllY2UgPT09IFBBV04gJiYgKHIgPT09IFJBTktfMSB8fCByID09PSBSQU5LXzgpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUFJPTU9USU9OUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvbW90aW9uID0gUFJPTU9USU9OU1tpXTtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgcGllY2UsXG4gICAgICAgICAgICAgICAgY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgcHJvbW90aW9uLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncyB8IEJJVFMuUFJPTU9USU9OLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBwaWVjZSxcbiAgICAgICAgICAgIGNhcHR1cmVkLFxuICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZmVyUGllY2VUeXBlKHNhbikge1xuICAgIGxldCBwaWVjZVR5cGUgPSBzYW4uY2hhckF0KDApO1xuICAgIGlmIChwaWVjZVR5cGUgPj0gJ2EnICYmIHBpZWNlVHlwZSA8PSAnaCcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNhbi5tYXRjaCgvW2EtaF1cXGQuKlthLWhdXFxkLyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQVdOO1xuICAgIH1cbiAgICBwaWVjZVR5cGUgPSBwaWVjZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocGllY2VUeXBlID09PSAnbycpIHtcbiAgICAgICAgcmV0dXJuIEtJTkc7XG4gICAgfVxuICAgIHJldHVybiBwaWVjZVR5cGU7XG59XG4vLyBwYXJzZXMgYWxsIG9mIHRoZSBkZWNvcmF0b3JzIG91dCBvZiBhIFNBTiBzdHJpbmdcbmZ1bmN0aW9uIHN0cmlwcGVkU2FuKG1vdmUpIHtcbiAgICByZXR1cm4gbW92ZS5yZXBsYWNlKC89LywgJycpLnJlcGxhY2UoL1srI10/Wz8hXSokLywgJycpO1xufVxuY2xhc3MgQ2hlc3Mge1xuICAgIF9ib2FyZCA9IG5ldyBBcnJheSgxMjgpO1xuICAgIF90dXJuID0gV0hJVEU7XG4gICAgX2hlYWRlciA9IHt9O1xuICAgIF9raW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH07XG4gICAgX2VwU3F1YXJlID0gLTE7XG4gICAgX2hhbGZNb3ZlcyA9IDA7XG4gICAgX21vdmVOdW1iZXIgPSAwO1xuICAgIF9oaXN0b3J5ID0gW107XG4gICAgX2NvbW1lbnRzID0ge307XG4gICAgX2Nhc3RsaW5nID0geyB3OiAwLCBiOiAwIH07XG4gICAgX2hhc2ggPSAwbjtcbiAgICAvLyB0cmFja3MgbnVtYmVyIG9mIHRpbWVzIGEgcG9zaXRpb24gaGFzIGJlZW4gc2VlbiBmb3IgcmVwZXRpdGlvbiBjaGVja2luZ1xuICAgIF9wb3NpdGlvbkNvdW50ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0cnVjdG9yKGZlbiA9IERFRkFVTFRfUE9TSVRJT04sIHsgc2tpcFZhbGlkYXRpb24gPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5sb2FkKGZlbiwgeyBza2lwVmFsaWRhdGlvbiB9KTtcbiAgICB9XG4gICAgY2xlYXIoeyBwcmVzZXJ2ZUhlYWRlcnMgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5fYm9hcmQgPSBuZXcgQXJyYXkoMTI4KTtcbiAgICAgICAgdGhpcy5fa2luZ3MgPSB7IHc6IEVNUFRZLCBiOiBFTVBUWSB9O1xuICAgICAgICB0aGlzLl90dXJuID0gV0hJVEU7XG4gICAgICAgIHRoaXMuX2Nhc3RsaW5nID0geyB3OiAwLCBiOiAwIH07XG4gICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IDA7XG4gICAgICAgIHRoaXMuX21vdmVOdW1iZXIgPSAxO1xuICAgICAgICB0aGlzLl9oaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMuX2NvbW1lbnRzID0ge307XG4gICAgICAgIHRoaXMuX2hlYWRlciA9IHByZXNlcnZlSGVhZGVycyA/IHRoaXMuX2hlYWRlciA6IHsgLi4uSEVBREVSX1RFTVBMQVRFIH07XG4gICAgICAgIHRoaXMuX2hhc2ggPSB0aGlzLl9jb21wdXRlSGFzaCgpO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBEZWxldGUgdGhlIFNldFVwIGFuZCBGRU4gaGVhZGVycyAoaWYgcHJlc2VydmVkKSwgdGhlIGJvYXJkIGlzIGVtcHR5IGFuZFxuICAgICAgICAgKiB0aGVzZSBoZWFkZXJzIGRvbid0IG1ha2Ugc2Vuc2UgaW4gdGhpcyBzdGF0ZS4gVGhleSdsbCBnZXQgYWRkZWQgbGF0ZXJcbiAgICAgICAgICogdmlhIC5sb2FkKCkgb3IgLnB1dCgpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oZWFkZXJbJ1NldFVwJ10gPSBudWxsO1xuICAgICAgICB0aGlzLl9oZWFkZXJbJ0ZFTiddID0gbnVsbDtcbiAgICB9XG4gICAgbG9hZChmZW4sIHsgc2tpcFZhbGlkYXRpb24gPSBmYWxzZSwgcHJlc2VydmVIZWFkZXJzID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIGxldCB0b2tlbnMgPSBmZW4uc3BsaXQoL1xccysvKTtcbiAgICAgICAgLy8gYXBwZW5kIGNvbW1vbmx5IG9taXR0ZWQgZmVuIHRva2Vuc1xuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+PSAyICYmIHRva2Vucy5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50cyA9IFsnLScsICctJywgJzAnLCAnMSddO1xuICAgICAgICAgICAgZmVuID0gdG9rZW5zLmNvbmNhdChhZGp1c3RtZW50cy5zbGljZSgtKDYgLSB0b2tlbnMubGVuZ3RoKSkpLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMgPSBmZW4uc3BsaXQoL1xccysvKTtcbiAgICAgICAgaWYgKCFza2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgeyBvaywgZXJyb3IgfSA9IHZhbGlkYXRlRmVuKGZlbik7XG4gICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRva2Vuc1swXTtcbiAgICAgICAgbGV0IHNxdWFyZSA9IDA7XG4gICAgICAgIHRoaXMuY2xlYXIoeyBwcmVzZXJ2ZUhlYWRlcnMgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gcG9zaXRpb24uY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKHBpZWNlID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBzcXVhcmUgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGlnaXQocGllY2UpKSB7XG4gICAgICAgICAgICAgICAgc3F1YXJlICs9IHBhcnNlSW50KHBpZWNlLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHBpZWNlIDwgJ2EnID8gV0hJVEUgOiBCTEFDSztcbiAgICAgICAgICAgICAgICB0aGlzLl9wdXQoeyB0eXBlOiBwaWVjZS50b0xvd2VyQ2FzZSgpLCBjb2xvciB9LCBhbGdlYnJhaWMoc3F1YXJlKSk7XG4gICAgICAgICAgICAgICAgc3F1YXJlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHVybiA9IHRva2Vuc1sxXTtcbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdLJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyB8PSBCSVRTLktTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ1EnKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy53IHw9IEJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZignaycpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgfD0gQklUUy5LU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdxJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiB8PSBCSVRTLlFTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IHRva2Vuc1szXSA9PT0gJy0nID8gRU1QVFkgOiBPeDg4W3Rva2Vuc1szXV07XG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IHBhcnNlSW50KHRva2Vuc1s0XSwgMTApO1xuICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyID0gcGFyc2VJbnQodG9rZW5zWzVdLCAxMCk7XG4gICAgICAgIHRoaXMuX2hhc2ggPSB0aGlzLl9jb21wdXRlSGFzaCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVTZXR1cChmZW4pO1xuICAgICAgICB0aGlzLl9pbmNQb3NpdGlvbkNvdW50KCk7XG4gICAgfVxuICAgIGZlbih7IGZvcmNlRW5wYXNzYW50U3F1YXJlID0gZmFsc2UsIH0gPSB7fSkge1xuICAgICAgICBsZXQgZW1wdHkgPSAwO1xuICAgICAgICBsZXQgZmVuID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmZW4gKz0gZW1wdHk7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2xvciwgdHlwZTogcGllY2UgfSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICAgICAgICAgIGZlbiArPSBjb2xvciA9PT0gV0hJVEUgPyBwaWVjZS50b1VwcGVyQ2FzZSgpIDogcGllY2UudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtcHR5Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlbiArPSBlbXB0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IE94ODguaDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVuICs9ICcvJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW1wdHkgPSAwO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FzdGxpbmcgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW1dISVRFXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAnSyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW1dISVRFXSAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAnUSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW0JMQUNLXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAnayc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW0JMQUNLXSAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBjYXN0bGluZyArPSAncSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gd2UgaGF2ZSBhbiBlbXB0eSBjYXN0bGluZyBmbGFnP1xuICAgICAgICBjYXN0bGluZyA9IGNhc3RsaW5nIHx8ICctJztcbiAgICAgICAgbGV0IGVwU3F1YXJlID0gJy0nO1xuICAgICAgICAvKlxuICAgICAgICAgKiBvbmx5IHByaW50IHRoZSBlcCBzcXVhcmUgaWYgZW4gcGFzc2FudCBpcyBhIHZhbGlkIG1vdmUgKHBhd24gaXMgcHJlc2VudFxuICAgICAgICAgKiBhbmQgZXAgY2FwdHVyZSBpcyBub3QgcGlubmVkKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuX2VwU3F1YXJlICE9PSBFTVBUWSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlRW5wYXNzYW50U3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgZXBTcXVhcmUgPSBhbGdlYnJhaWModGhpcy5fZXBTcXVhcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmlnUGF3blNxdWFyZSA9IHRoaXMuX2VwU3F1YXJlICsgKHRoaXMuX3R1cm4gPT09IFdISVRFID8gMTYgOiAtMTYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZXMgPSBbYmlnUGF3blNxdWFyZSArIDEsIGJpZ1Bhd25TcXVhcmUgLSAxXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNxdWFyZSBvZiBzcXVhcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHRoZSBzcXVhcmUgb2ZmIHRoZSBib2FyZD9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNxdWFyZSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fdHVybjtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhlcmUgYSBwYXduIHRoYXQgY2FuIGNhcHR1cmUgdGhlIGVwU3F1YXJlP1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbc3F1YXJlXT8uY29sb3IgPT09IGNvbG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGF3biBtYWtlcyBhbiBlcCBjYXB0dXJlLCBkb2VzIGl0IGxlYXZlIGl0cyBraW5nIGluIGNoZWNrP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5fZXBTcXVhcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGllY2U6IFBBV04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZWQ6IFBBV04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IEJJVFMuRVBfQ0FQVFVSRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNMZWdhbCA9ICF0aGlzLl9pc0tpbmdBdHRhY2tlZChjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZXAgaXMgbGVnYWwsIGJyZWFrIGFuZCBzZXQgdGhlIGVwIHNxdWFyZSBpbiB0aGUgRkVOIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVnYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcFNxdWFyZSA9IGFsZ2VicmFpYyh0aGlzLl9lcFNxdWFyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZlbixcbiAgICAgICAgICAgIHRoaXMuX3R1cm4sXG4gICAgICAgICAgICBjYXN0bGluZyxcbiAgICAgICAgICAgIGVwU3F1YXJlLFxuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzLFxuICAgICAgICAgICAgdGhpcy5fbW92ZU51bWJlcixcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgfVxuICAgIF9waWVjZUtleShpKSB7XG4gICAgICAgIGlmICghdGhpcy5fYm9hcmRbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiAwbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvbG9yLCB0eXBlIH0gPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgY29uc3QgY29sb3JJbmRleCA9IHtcbiAgICAgICAgICAgIHc6IDAsXG4gICAgICAgICAgICBiOiAxLFxuICAgICAgICB9W2NvbG9yXTtcbiAgICAgICAgY29uc3QgdHlwZUluZGV4ID0ge1xuICAgICAgICAgICAgcDogMCxcbiAgICAgICAgICAgIG46IDEsXG4gICAgICAgICAgICBiOiAyLFxuICAgICAgICAgICAgcjogMyxcbiAgICAgICAgICAgIHE6IDQsXG4gICAgICAgICAgICBrOiA1LFxuICAgICAgICB9W3R5cGVdO1xuICAgICAgICByZXR1cm4gUElFQ0VfS0VZU1tjb2xvckluZGV4XVt0eXBlSW5kZXhdW2ldO1xuICAgIH1cbiAgICBfZXBLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcFNxdWFyZSA9PT0gRU1QVFkgPyAwbiA6IEVQX0tFWVNbdGhpcy5fZXBTcXVhcmUgJiA3XTtcbiAgICB9XG4gICAgX2Nhc3RsaW5nS2V5KCkge1xuICAgICAgICBjb25zdCBpbmRleCA9ICh0aGlzLl9jYXN0bGluZy53ID4+IDUpIHwgKHRoaXMuX2Nhc3RsaW5nLmIgPj4gMyk7XG4gICAgICAgIHJldHVybiBDQVNUTElOR19LRVlTW2luZGV4XTtcbiAgICB9XG4gICAgX2NvbXB1dGVIYXNoKCkge1xuICAgICAgICBsZXQgaGFzaCA9IDBuO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGRpZCB3ZSBydW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGJvYXJkXG4gICAgICAgICAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBpICs9IDc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0pIHtcbiAgICAgICAgICAgICAgICBoYXNoIF49IHRoaXMuX3BpZWNlS2V5KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhc2ggXj0gdGhpcy5fZXBLZXkoKTtcbiAgICAgICAgaGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xuICAgICAgICBpZiAodGhpcy5fdHVybiA9PT0gJ2InKSB7XG4gICAgICAgICAgICBoYXNoIF49IFNJREVfS0VZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgICAvKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBpbml0aWFsIGJvYXJkIHNldHVwIGlzIGNoYW5nZWQgd2l0aCBwdXQoKSBvciByZW1vdmUoKS5cbiAgICAgKiBtb2RpZmllcyB0aGUgU2V0VXAgYW5kIEZFTiBwcm9wZXJ0aWVzIG9mIHRoZSBoZWFkZXIgb2JqZWN0LiBJZiB0aGUgRkVOXG4gICAgICogaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb24sIHRoZSBTZXRVcCBhbmQgRkVOIGFyZSBkZWxldGVkIHRoZSBzZXR1cFxuICAgICAqIGlzIG9ubHkgdXBkYXRlZCBpZiBoaXN0b3J5Lmxlbmd0aCBpcyB6ZXJvLCBpZSBtb3ZlcyBoYXZlbid0IGJlZW4gbWFkZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlU2V0dXAoZmVuKSB7XG4gICAgICAgIGlmICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChmZW4gIT09IERFRkFVTFRfUE9TSVRJT04pIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnU2V0VXAnXSA9ICcxJztcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnRkVOJ10gPSBmZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJbJ1NldFVwJ10gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyWydGRU4nXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubG9hZChERUZBVUxUX1BPU0lUSU9OKTtcbiAgICB9XG4gICAgZ2V0KHNxdWFyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9hcmRbT3g4OFtzcXVhcmVdXTtcbiAgICB9XG4gICAgZmluZFBpZWNlKHBpZWNlKSB7XG4gICAgICAgIGNvbnN0IHNxdWFyZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IE94ODguYTg7IGkgPD0gT3g4OC5oMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBkaWQgd2UgcnVuIG9mZiB0aGUgZW5kIG9mIHRoZSBib2FyZFxuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgZW1wdHkgc3F1YXJlIG9yIHdyb25nIGNvbG9yXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2ldIHx8IHRoaXMuX2JvYXJkW2ldPy5jb2xvciAhPT0gcGllY2UuY29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHNxdWFyZSBjb250YWlucyB0aGUgcmVxdWVzdGVkIHBpZWNlXG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0uY29sb3IgPT09IHBpZWNlLmNvbG9yICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbaV0udHlwZSA9PT0gcGllY2UudHlwZSkge1xuICAgICAgICAgICAgICAgIHNxdWFyZXMucHVzaChhbGdlYnJhaWMoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcXVhcmVzO1xuICAgIH1cbiAgICBwdXQoeyB0eXBlLCBjb2xvciB9LCBzcXVhcmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3B1dCh7IHR5cGUsIGNvbG9yIH0sIHNxdWFyZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNhc3RsaW5nUmlnaHRzKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVFblBhc3NhbnRTcXVhcmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKHRoaXMuZmVuKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfc2V0KHNxLCBwaWVjZSkge1xuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX3BpZWNlS2V5KHNxKTtcbiAgICAgICAgdGhpcy5fYm9hcmRbc3FdID0gcGllY2U7XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fcGllY2VLZXkoc3EpO1xuICAgIH1cbiAgICBfcHV0KHsgdHlwZSwgY29sb3IgfSwgc3F1YXJlKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBwaWVjZVxuICAgICAgICBpZiAoU1lNQk9MUy5pbmRleE9mKHR5cGUudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIHZhbGlkIHNxdWFyZVxuICAgICAgICBpZiAoIShzcXVhcmUgaW4gT3g4OCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcSA9IE94ODhbc3F1YXJlXTtcbiAgICAgICAgLy8gZG9uJ3QgbGV0IHRoZSB1c2VyIHBsYWNlIG1vcmUgdGhhbiBvbmUga2luZ1xuICAgICAgICBpZiAodHlwZSA9PSBLSU5HICYmXG4gICAgICAgICAgICAhKHRoaXMuX2tpbmdzW2NvbG9yXSA9PSBFTVBUWSB8fCB0aGlzLl9raW5nc1tjb2xvcl0gPT0gc3EpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFBpZWNlT25TcXVhcmUgPSB0aGlzLl9ib2FyZFtzcV07XG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUga2luZ3Mgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgcGllY2UgZnJvbSBhcmdzLCBzZXQgdGhlIGBfa2luZ3NgIHJlc3BlY3RpdmUgZW50cnkgdG8gYEVNUFRZYFxuICAgICAgICBpZiAoY3VycmVudFBpZWNlT25TcXVhcmUgJiYgY3VycmVudFBpZWNlT25TcXVhcmUudHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbY3VycmVudFBpZWNlT25TcXVhcmUuY29sb3JdID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0KHNxLCB7IHR5cGU6IHR5cGUsIGNvbG9yOiBjb2xvciB9KTtcbiAgICAgICAgaWYgKHR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW2NvbG9yXSA9IHNxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfY2xlYXIoc3EpIHtcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleShzcSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtzcV07XG4gICAgfVxuICAgIHJlbW92ZShzcXVhcmUpIHtcbiAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLmdldChzcXVhcmUpO1xuICAgICAgICB0aGlzLl9jbGVhcihPeDg4W3NxdWFyZV0pO1xuICAgICAgICBpZiAocGllY2UgJiYgcGllY2UudHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbcGllY2UuY29sb3JdID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRW5QYXNzYW50U3F1YXJlKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKHRoaXMuZmVuKCkpO1xuICAgICAgICByZXR1cm4gcGllY2U7XG4gICAgfVxuICAgIF91cGRhdGVDYXN0bGluZ1JpZ2h0cygpIHtcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xuICAgICAgICBjb25zdCB3aGl0ZUtpbmdJblBsYWNlID0gdGhpcy5fYm9hcmRbT3g4OC5lMV0/LnR5cGUgPT09IEtJTkcgJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguZTFdPy5jb2xvciA9PT0gV0hJVEU7XG4gICAgICAgIGNvbnN0IGJsYWNrS2luZ0luUGxhY2UgPSB0aGlzLl9ib2FyZFtPeDg4LmU4XT8udHlwZSA9PT0gS0lORyAmJlxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5lOF0/LmNvbG9yID09PSBCTEFDSztcbiAgICAgICAgaWYgKCF3aGl0ZUtpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmExXT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hMV0/LmNvbG9yICE9PSBXSElURSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyAmPSAtNjU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aGl0ZUtpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmgxXT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oMV0/LmNvbG9yICE9PSBXSElURSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyAmPSAtMzM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFibGFja0tpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmE4XT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hOF0/LmNvbG9yICE9PSBCTEFDSykge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiAmPSAtNjU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFibGFja0tpbmdJblBsYWNlIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4Lmg4XT8udHlwZSAhPT0gUk9PSyB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oOF0/LmNvbG9yICE9PSBCTEFDSykge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiAmPSAtMzM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xuICAgIH1cbiAgICBfdXBkYXRlRW5QYXNzYW50U3F1YXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fZXBTcXVhcmUgPT09IEVNUFRZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRTcXVhcmUgPSB0aGlzLl9lcFNxdWFyZSArICh0aGlzLl90dXJuID09PSBXSElURSA/IC0xNiA6IDE2KTtcbiAgICAgICAgY29uc3QgY3VycmVudFNxdWFyZSA9IHRoaXMuX2VwU3F1YXJlICsgKHRoaXMuX3R1cm4gPT09IFdISVRFID8gMTYgOiAtMTYpO1xuICAgICAgICBjb25zdCBhdHRhY2tlcnMgPSBbY3VycmVudFNxdWFyZSArIDEsIGN1cnJlbnRTcXVhcmUgLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3N0YXJ0U3F1YXJlXSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbdGhpcy5fZXBTcXVhcmVdICE9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjdXJyZW50U3F1YXJlXT8uY29sb3IgIT09IHN3YXBDb2xvcih0aGlzLl90dXJuKSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbY3VycmVudFNxdWFyZV0/LnR5cGUgIT09IFBBV04pIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fZXBLZXkoKTtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuQ2FwdHVyZSA9IChzcXVhcmUpID0+ICEoc3F1YXJlICYgMHg4OCkgJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW3NxdWFyZV0/LmNvbG9yID09PSB0aGlzLl90dXJuICYmXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBQQVdOO1xuICAgICAgICBpZiAoIWF0dGFja2Vycy5zb21lKGNhbkNhcHR1cmUpKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2VwS2V5KCk7XG4gICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hdHRhY2tlZChjb2xvciwgc3F1YXJlLCB2ZXJib3NlKSB7XG4gICAgICAgIGNvbnN0IGF0dGFja2VycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGRpZCB3ZSBydW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGJvYXJkXG4gICAgICAgICAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBpICs9IDc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBlbXB0eSBzcXVhcmUgb3Igd3JvbmcgY29sb3JcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2JvYXJkW2ldLmNvbG9yICE9PSBjb2xvcikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBpIC0gc3F1YXJlO1xuICAgICAgICAgICAgLy8gc2tpcCAtIHRvL2Zyb20gc3F1YXJlIGFyZSB0aGUgc2FtZVxuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZGlmZmVyZW5jZSArIDExOTtcbiAgICAgICAgICAgIGlmIChBVFRBQ0tTW2luZGV4XSAmIFBJRUNFX01BU0tTW3BpZWNlLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IFBBV04pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkaWZmZXJlbmNlID4gMCAmJiBwaWVjZS5jb2xvciA9PT0gV0hJVEUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZGlmZmVyZW5jZSA8PSAwICYmIHBpZWNlLmNvbG9yID09PSBCTEFDSykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNrZXJzLnB1c2goYWxnZWJyYWljKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBpZWNlIGlzIGEga25pZ2h0IG9yIGEga2luZ1xuICAgICAgICAgICAgICAgIGlmIChwaWVjZS50eXBlID09PSAnbicgfHwgcGllY2UudHlwZSA9PT0gJ2snKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2tlcnMucHVzaChhbGdlYnJhaWMoaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gUkFZU1tpbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGogPSBpICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGxldCBibG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGogIT09IHNxdWFyZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbal0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBqICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFibG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2tlcnMucHVzaChhbGdlYnJhaWMoaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRhY2tlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNrZXJzKHNxdWFyZSwgYXR0YWNrZWRCeSkge1xuICAgICAgICBpZiAoIWF0dGFja2VkQnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2tlZCh0aGlzLl90dXJuLCBPeDg4W3NxdWFyZV0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKGF0dGFja2VkQnksIE94ODhbc3F1YXJlXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2lzS2luZ0F0dGFja2VkKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMuX2tpbmdzW2NvbG9yXTtcbiAgICAgICAgcmV0dXJuIHNxdWFyZSA9PT0gLTEgPyBmYWxzZSA6IHRoaXMuX2F0dGFja2VkKHN3YXBDb2xvcihjb2xvciksIHNxdWFyZSk7XG4gICAgfVxuICAgIGhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNoLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgaXNBdHRhY2tlZChzcXVhcmUsIGF0dGFja2VkQnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKGF0dGFja2VkQnksIE94ODhbc3F1YXJlXSk7XG4gICAgfVxuICAgIGlzQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0tpbmdBdHRhY2tlZCh0aGlzLl90dXJuKTtcbiAgICB9XG4gICAgaW5DaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpO1xuICAgIH1cbiAgICBpc0NoZWNrbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpICYmIHRoaXMuX21vdmVzKCkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc1N0YWxlbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ2hlY2soKSAmJiB0aGlzLl9tb3ZlcygpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogay5iLiB2cyBrLmIuIChvZiBvcHBvc2l0ZSBjb2xvcnMpIHdpdGggbWF0ZSBpbiAxOlxuICAgICAgICAgKiA4LzgvOC84LzFiNi84L0IxazUvSzcgYiAtIC0gMCAxXG4gICAgICAgICAqXG4gICAgICAgICAqIGsuYi4gdnMgay5uLiB3aXRoIG1hdGUgaW4gMTpcbiAgICAgICAgICogOC84LzgvOC8xbjYvOC9CNy9LMWs1IGIgLSAtIDIgMVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcGllY2VzID0ge1xuICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIG46IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgcTogMCxcbiAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICBwOiAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBiaXNob3BzID0gW107XG4gICAgICAgIGxldCBudW1QaWVjZXMgPSAwO1xuICAgICAgICBsZXQgc3F1YXJlQ29sb3IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIHNxdWFyZUNvbG9yID0gKHNxdWFyZUNvbG9yICsgMSkgJSAyO1xuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgIGlmIChwaWVjZSkge1xuICAgICAgICAgICAgICAgIHBpZWNlc1twaWVjZS50eXBlXSA9IHBpZWNlLnR5cGUgaW4gcGllY2VzID8gcGllY2VzW3BpZWNlLnR5cGVdICsgMSA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IEJJU0hPUCkge1xuICAgICAgICAgICAgICAgICAgICBiaXNob3BzLnB1c2goc3F1YXJlQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1QaWVjZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBrIHZzLiBrXG4gICAgICAgIGlmIChudW1QaWVjZXMgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBrIHZzLiBrbiAuLi4uIG9yIC4uLi4gayB2cy4ga2JcbiAgICAgICAgbnVtUGllY2VzID09PSAzICYmXG4gICAgICAgICAgICAocGllY2VzW0JJU0hPUF0gPT09IDEgfHwgcGllY2VzW0tOSUdIVF0gPT09IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1QaWVjZXMgPT09IHBpZWNlc1tCSVNIT1BdICsgMikge1xuICAgICAgICAgICAgLy8ga2IgdnMuIGtiIHdoZXJlIGFueSBudW1iZXIgb2YgYmlzaG9wcyBhcmUgYWxsIG9uIHRoZSBzYW1lIGNvbG9yXG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJpc2hvcHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bSArPSBiaXNob3BzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1bSA9PT0gMCB8fCBzdW0gPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNUaHJlZWZvbGRSZXBldGl0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UG9zaXRpb25Db3VudCh0aGlzLl9oYXNoKSA+PSAzO1xuICAgIH1cbiAgICBpc0RyYXdCeUZpZnR5TW92ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYWxmTW92ZXMgPj0gMTAwOyAvLyA1MCBtb3ZlcyBwZXIgc2lkZSA9IDEwMCBoYWxmIG1vdmVzXG4gICAgfVxuICAgIGlzRHJhdygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzRHJhd0J5RmlmdHlNb3ZlcygpIHx8XG4gICAgICAgICAgICB0aGlzLmlzU3RhbGVtYXRlKCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHx8XG4gICAgICAgICAgICB0aGlzLmlzVGhyZWVmb2xkUmVwZXRpdGlvbigpKTtcbiAgICB9XG4gICAgaXNHYW1lT3ZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVja21hdGUoKSB8fCB0aGlzLmlzRHJhdygpO1xuICAgIH1cbiAgICBtb3Zlcyh7IHZlcmJvc2UgPSBmYWxzZSwgc3F1YXJlID0gdW5kZWZpbmVkLCBwaWVjZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5fbW92ZXMoeyBzcXVhcmUsIHBpZWNlIH0pO1xuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vdmVzLm1hcCgobW92ZSkgPT4gbmV3IE1vdmUodGhpcywgbW92ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vdmVzLm1hcCgobW92ZSkgPT4gdGhpcy5fbW92ZVRvU2FuKG1vdmUsIG1vdmVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21vdmVzKHsgbGVnYWwgPSB0cnVlLCBwaWVjZSA9IHVuZGVmaW5lZCwgc3F1YXJlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZm9yU3F1YXJlID0gc3F1YXJlID8gc3F1YXJlLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGZvclBpZWNlID0gcGllY2U/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IG1vdmVzID0gW107XG4gICAgICAgIGNvbnN0IHVzID0gdGhpcy5fdHVybjtcbiAgICAgICAgY29uc3QgdGhlbSA9IHN3YXBDb2xvcih1cyk7XG4gICAgICAgIGxldCBmaXJzdFNxdWFyZSA9IE94ODguYTg7XG4gICAgICAgIGxldCBsYXN0U3F1YXJlID0gT3g4OC5oMTtcbiAgICAgICAgbGV0IHNpbmdsZVNxdWFyZSA9IGZhbHNlO1xuICAgICAgICAvLyBhcmUgd2UgZ2VuZXJhdGluZyBtb3ZlcyBmb3IgYSBzaW5nbGUgc3F1YXJlP1xuICAgICAgICBpZiAoZm9yU3F1YXJlKSB7XG4gICAgICAgICAgICAvLyBpbGxlZ2FsIHNxdWFyZSwgcmV0dXJuIGVtcHR5IG1vdmVzXG4gICAgICAgICAgICBpZiAoIShmb3JTcXVhcmUgaW4gT3g4OCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXJzdFNxdWFyZSA9IGxhc3RTcXVhcmUgPSBPeDg4W2ZvclNxdWFyZV07XG4gICAgICAgICAgICAgICAgc2luZ2xlU3F1YXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBmcm9tID0gZmlyc3RTcXVhcmU7IGZyb20gPD0gbGFzdFNxdWFyZTsgZnJvbSsrKSB7XG4gICAgICAgICAgICAvLyBkaWQgd2UgcnVuIG9mZiB0aGUgZW5kIG9mIHRoZSBib2FyZFxuICAgICAgICAgICAgaWYgKGZyb20gJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgZnJvbSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW1wdHkgc3F1YXJlIG9yIG9wcG9uZW50LCBza2lwXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Zyb21dIHx8IHRoaXMuX2JvYXJkW2Zyb21dLmNvbG9yID09PSB0aGVtKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHRoaXMuX2JvYXJkW2Zyb21dO1xuICAgICAgICAgICAgbGV0IHRvO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFBBV04pIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yUGllY2UgJiYgZm9yUGllY2UgIT09IHR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBzcXVhcmUsIG5vbi1jYXB0dXJpbmdcbiAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBQQVdOX09GRlNFVFNbdXNdWzBdO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbdG9dKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgUEFXTik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvdWJsZSBzcXVhcmVcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgUEFXTl9PRkZTRVRTW3VzXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNFQ09ORF9SQU5LW3VzXSA9PT0gcmFuayhmcm9tKSAmJiAhdGhpcy5fYm9hcmRbdG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04sIHVuZGVmaW5lZCwgQklUUy5CSUdfUEFXTik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGF3biBjYXB0dXJlc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAyOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbSArIFBBV05fT0ZGU0VUU1t1c11bal07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0byAmIDB4ODgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3RvXT8uY29sb3IgPT09IHRoZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgUEFXTiwgdGhpcy5fYm9hcmRbdG9dLnR5cGUsIEJJVFMuQ0FQVFVSRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG8gPT09IHRoaXMuX2VwU3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04sIFBBV04sIEJJVFMuRVBfQ0FQVFVSRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yUGllY2UgJiYgZm9yUGllY2UgIT09IHR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBsZW4gPSBQSUVDRV9PRkZTRVRTW3R5cGVdLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IFBJRUNFX09GRlNFVFNbdHlwZV1bal07XG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0byAmIDB4ODgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvd24gY29sb3IsIHN0b3AgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFt0b10uY29sb3IgPT09IHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIHR5cGUsIHRoaXMuX2JvYXJkW3RvXS50eXBlLCBCSVRTLkNBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyogYnJlYWssIGlmIGtuaWdodCBvciBraW5nICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gS05JR0hUIHx8IHR5cGUgPT09IEtJTkcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogY2hlY2sgZm9yIGNhc3RsaW5nIGlmIHdlJ3JlOlxuICAgICAgICAgKiAgIGEpIGdlbmVyYXRpbmcgYWxsIG1vdmVzLCBvclxuICAgICAgICAgKiAgIGIpIGRvaW5nIHNpbmdsZSBzcXVhcmUgbW92ZSBnZW5lcmF0aW9uIG9uIHRoZSBraW5nJ3Mgc3F1YXJlXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZm9yUGllY2UgPT09IHVuZGVmaW5lZCB8fCBmb3JQaWVjZSA9PT0gS0lORykge1xuICAgICAgICAgICAgaWYgKCFzaW5nbGVTcXVhcmUgfHwgbGFzdFNxdWFyZSA9PT0gdGhpcy5fa2luZ3NbdXNdKSB7XG4gICAgICAgICAgICAgICAgLy8ga2luZy1zaWRlIGNhc3RsaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IHRoaXMuX2tpbmdzW3VzXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IGNhc3RsaW5nRnJvbSArIDI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tICsgMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9ib2FyZFtjYXN0bGluZ1RvXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIHRoaXMuX2tpbmdzW3VzXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ0Zyb20gKyAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nVG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgdGhpcy5fa2luZ3NbdXNdLCBjYXN0bGluZ1RvLCBLSU5HLCB1bmRlZmluZWQsIEJJVFMuS1NJREVfQ0FTVExFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBxdWVlbi1zaWRlIGNhc3RsaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IHRoaXMuX2tpbmdzW3VzXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IGNhc3RsaW5nRnJvbSAtIDI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tIC0gMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb20gLSAyXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSAtIDNdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgdGhpcy5fa2luZ3NbdXNdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nRnJvbSAtIDEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdUbykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCB0aGlzLl9raW5nc1t1c10sIGNhc3RsaW5nVG8sIEtJTkcsIHVuZGVmaW5lZCwgQklUUy5RU0lERV9DQVNUTEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIHJldHVybiBhbGwgcHNldWRvLWxlZ2FsIG1vdmVzICh0aGlzIGluY2x1ZGVzIG1vdmVzIHRoYXQgYWxsb3cgdGhlIGtpbmdcbiAgICAgICAgICogdG8gYmUgY2FwdHVyZWQpXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWxlZ2FsIHx8IHRoaXMuX2tpbmdzW3VzXSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3ZlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBmaWx0ZXIgb3V0IGlsbGVnYWwgbW92ZXNcbiAgICAgICAgY29uc3QgbGVnYWxNb3ZlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNLaW5nQXR0YWNrZWQodXMpKSB7XG4gICAgICAgICAgICAgICAgbGVnYWxNb3Zlcy5wdXNoKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZ2FsTW92ZXM7XG4gICAgfVxuICAgIG1vdmUobW92ZSwgeyBzdHJpY3QgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIG1vdmUgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB3aXRoIGluIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgICAgICpcbiAgICAgICAgICogLm1vdmUoJ054YjcnKSAgICAgICA8LSBhcmd1bWVudCBpcyBhIGNhc2Utc2Vuc2l0aXZlIFNBTiBzdHJpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogLm1vdmUoeyBmcm9tOiAnaDcnLCA8LSBhcmd1bWVudCBpcyBhIG1vdmUgb2JqZWN0XG4gICAgICAgICAqICAgICAgICAgdG8gOidoOCcsXG4gICAgICAgICAqICAgICAgICAgcHJvbW90aW9uOiAncScgfSlcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogQW4gb3B0aW9uYWwgc3RyaWN0IGFyZ3VtZW50IG1heSBiZSBzdXBwbGllZCB0byB0ZWxsIGNoZXNzLmpzIHRvXG4gICAgICAgICAqIHN0cmljdGx5IGZvbGxvdyB0aGUgU0FOIHNwZWNpZmljYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbW92ZU9iaiA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgbW92ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1vdmVPYmogPSB0aGlzLl9tb3ZlRnJvbVNhbihtb3ZlLCBzdHJpY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vdmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdmVPYmogPSB0aGlzLl9tb3ZlRnJvbVNhbihTQU5fTlVMTE1PVkUsIHN0cmljdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vdmUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlcyA9IHRoaXMuX21vdmVzKCk7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBwcmV0dHkgbW92ZSBvYmplY3QgdG8gYW4gdWdseSBtb3ZlIG9iamVjdFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmUuZnJvbSA9PT0gYWxnZWJyYWljKG1vdmVzW2ldLmZyb20pICYmXG4gICAgICAgICAgICAgICAgICAgIG1vdmUudG8gPT09IGFsZ2VicmFpYyhtb3Zlc1tpXS50bykgJiZcbiAgICAgICAgICAgICAgICAgICAgKCEoJ3Byb21vdGlvbicgaW4gbW92ZXNbaV0pIHx8IG1vdmUucHJvbW90aW9uID09PSBtb3Zlc1tpXS5wcm9tb3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVPYmogPSBtb3Zlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZhaWxlZCB0byBmaW5kIG1vdmVcbiAgICAgICAgaWYgKCFtb3ZlT2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vdmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vdmU6ICR7bW92ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb3ZlOiAke0pTT04uc3RyaW5naWZ5KG1vdmUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZGlzYWxsb3cgbnVsbCBtb3ZlcyB3aGVuIGluIGNoZWNrXG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2soKSAmJiBtb3ZlT2JqLmZsYWdzICYgQklUUy5OVUxMX01PVkUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVsbCBtb3ZlIG5vdCBhbGxvd2VkIHdoZW4gaW4gY2hlY2snKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBuZWVkIHRvIG1ha2UgYSBjb3B5IG9mIG1vdmUgYmVjYXVzZSB3ZSBjYW4ndCBnZW5lcmF0ZSBTQU4gYWZ0ZXIgdGhlIG1vdmVcbiAgICAgICAgICogaXMgbWFkZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcHJldHR5TW92ZSA9IG5ldyBNb3ZlKHRoaXMsIG1vdmVPYmopO1xuICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlT2JqKTtcbiAgICAgICAgdGhpcy5faW5jUG9zaXRpb25Db3VudCgpO1xuICAgICAgICByZXR1cm4gcHJldHR5TW92ZTtcbiAgICB9XG4gICAgX3B1c2gobW92ZSkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgbW92ZSxcbiAgICAgICAgICAgIGtpbmdzOiB7IGI6IHRoaXMuX2tpbmdzLmIsIHc6IHRoaXMuX2tpbmdzLncgfSxcbiAgICAgICAgICAgIHR1cm46IHRoaXMuX3R1cm4sXG4gICAgICAgICAgICBjYXN0bGluZzogeyBiOiB0aGlzLl9jYXN0bGluZy5iLCB3OiB0aGlzLl9jYXN0bGluZy53IH0sXG4gICAgICAgICAgICBlcFNxdWFyZTogdGhpcy5fZXBTcXVhcmUsXG4gICAgICAgICAgICBoYWxmTW92ZXM6IHRoaXMuX2hhbGZNb3ZlcyxcbiAgICAgICAgICAgIG1vdmVOdW1iZXI6IHRoaXMuX21vdmVOdW1iZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbW92ZVBpZWNlKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fcGllY2VLZXkoZnJvbSk7XG4gICAgICAgIHRoaXMuX2JvYXJkW3RvXSA9IHRoaXMuX2JvYXJkW2Zyb21dO1xuICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbZnJvbV07XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fcGllY2VLZXkodG8pO1xuICAgIH1cbiAgICBfbWFrZU1vdmUobW92ZSkge1xuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xuICAgICAgICB0aGlzLl9wdXNoKG1vdmUpO1xuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuTlVMTF9NT1ZFKSB7XG4gICAgICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZU51bWJlcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzKys7XG4gICAgICAgICAgICB0aGlzLl90dXJuID0gdGhlbTtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9lcEtleSgpO1xuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XG4gICAgICAgIGlmIChtb3ZlLmNhcHR1cmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX3BpZWNlS2V5KG1vdmUudG8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vdmVQaWVjZShtb3ZlLmZyb20sIG1vdmUudG8pO1xuICAgICAgICAvLyBpZiBlcCBjYXB0dXJlLCByZW1vdmUgdGhlIGNhcHR1cmVkIHBhd25cbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLkVQX0NBUFRVUkUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90dXJuID09PSBCTEFDSykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyKG1vdmUudG8gLSAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhcihtb3ZlLnRvICsgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHBhd24gcHJvbW90aW9uLCByZXBsYWNlIHdpdGggbmV3IHBpZWNlXG4gICAgICAgIGlmIChtb3ZlLnByb21vdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXIobW92ZS50byk7XG4gICAgICAgICAgICB0aGlzLl9zZXQobW92ZS50bywgeyB0eXBlOiBtb3ZlLnByb21vdGlvbiwgY29sb3I6IHVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIG1vdmVkIHRoZSBraW5nXG4gICAgICAgIGlmICh0aGlzLl9ib2FyZFttb3ZlLnRvXS50eXBlID09PSBLSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9raW5nc1t1c10gPSBtb3ZlLnRvO1xuICAgICAgICAgICAgLy8gaWYgd2UgY2FzdGxlZCwgbW92ZSB0aGUgcm9vayBuZXh0IHRvIHRoZSBraW5nXG4gICAgICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IG1vdmUudG8gLSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVQaWVjZShjYXN0bGluZ0Zyb20sIGNhc3RsaW5nVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gLSAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVQaWVjZShjYXN0bGluZ0Zyb20sIGNhc3RsaW5nVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmdcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmcgaWYgd2UgbW92ZSBhIHJvb2tcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IFJPT0tTW3VzXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlLmZyb20gPT09IFJPT0tTW3VzXVtpXS5zcXVhcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdXNdICYgUk9PS1NbdXNdW2ldLmZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdXNdIF49IFJPT0tTW3VzXVtpXS5mbGFnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmcgaWYgd2UgY2FwdHVyZSBhIHJvb2tcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3RoZW1dKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gUk9PS1NbdGhlbV0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS50byA9PT0gUk9PS1NbdGhlbV1baV0uc3F1YXJlICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3RoZW1dICYgUk9PS1NbdGhlbV1baV0uZmxhZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t0aGVtXSBePSBST09LU1t0aGVtXVtpXS5mbGFnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xuICAgICAgICAvLyBpZiBiaWcgcGF3biBtb3ZlLCB1cGRhdGUgdGhlIGVuIHBhc3NhbnQgc3F1YXJlXG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5CSUdfUEFXTikge1xuICAgICAgICAgICAgbGV0IGVwU3F1YXJlO1xuICAgICAgICAgICAgaWYgKHVzID09PSBCTEFDSykge1xuICAgICAgICAgICAgICAgIGVwU3F1YXJlID0gbW92ZS50byAtIDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXBTcXVhcmUgPSBtb3ZlLnRvICsgMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKCEoKG1vdmUudG8gLSAxKSAmIDB4ODgpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50byAtIDFdPy50eXBlID09PSBQQVdOICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50byAtIDFdPy5jb2xvciA9PT0gdGhlbSkgfHxcbiAgICAgICAgICAgICAgICAoISgobW92ZS50byArIDEpICYgMHg4OCkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50byArIDFdPy50eXBlID09PSBQQVdOICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JvYXJkW21vdmUudG8gKyAxXT8uY29sb3IgPT09IHRoZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBlcFNxdWFyZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2VwS2V5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCB0aGUgNTAgbW92ZSBjb3VudGVyIGlmIGEgcGF3biBpcyBtb3ZlZCBvciBhIHBpZWNlIGlzIGNhcHR1cmVkXG4gICAgICAgIGlmIChtb3ZlLnBpZWNlID09PSBQQVdOKSB7XG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5DQVBUVVJFIHwgQklUUy5FUF9DQVBUVVJFKSkge1xuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX21vdmVOdW1iZXIrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90dXJuID0gdGhlbTtcbiAgICAgICAgdGhpcy5faGFzaCBePSBTSURFX0tFWTtcbiAgICB9XG4gICAgdW5kbygpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuX2hhc2g7XG4gICAgICAgIGNvbnN0IG1vdmUgPSB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgICAgY29uc3QgcHJldHR5TW92ZSA9IG5ldyBNb3ZlKHRoaXMsIG1vdmUpO1xuICAgICAgICAgICAgdGhpcy5fZGVjUG9zaXRpb25Db3VudChoYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV0dHlNb3ZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfdW5kb01vdmUoKSB7XG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuX2hpc3RvcnkucG9wKCk7XG4gICAgICAgIGlmIChvbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9lcEtleSgpO1xuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XG4gICAgICAgIGNvbnN0IG1vdmUgPSBvbGQubW92ZTtcbiAgICAgICAgdGhpcy5fa2luZ3MgPSBvbGQua2luZ3M7XG4gICAgICAgIHRoaXMuX3R1cm4gPSBvbGQudHVybjtcbiAgICAgICAgdGhpcy5fY2FzdGxpbmcgPSBvbGQuY2FzdGxpbmc7XG4gICAgICAgIHRoaXMuX2VwU3F1YXJlID0gb2xkLmVwU3F1YXJlO1xuICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSBvbGQuaGFsZk1vdmVzO1xuICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyID0gb2xkLm1vdmVOdW1iZXI7XG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fZXBLZXkoKTtcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xuICAgICAgICB0aGlzLl9oYXNoIF49IFNJREVfS0VZO1xuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuTlVMTF9NT1ZFKSB7XG4gICAgICAgICAgICByZXR1cm4gbW92ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3ZlUGllY2UobW92ZS50bywgbW92ZS5mcm9tKTtcbiAgICAgICAgLy8gdG8gdW5kbyBhbnkgcHJvbW90aW9uc1xuICAgICAgICBpZiAobW92ZS5waWVjZSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXIobW92ZS5mcm9tKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChtb3ZlLmZyb20sIHsgdHlwZTogbW92ZS5waWVjZSwgY29sb3I6IHVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlLmNhcHR1cmVkKSB7XG4gICAgICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuRVBfQ0FQVFVSRSkge1xuICAgICAgICAgICAgICAgIC8vIGVuIHBhc3NhbnQgY2FwdHVyZVxuICAgICAgICAgICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbW92ZS50byAtIDE2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBtb3ZlLnRvICsgMTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldChpbmRleCwgeyB0eXBlOiBQQVdOLCBjb2xvcjogdGhlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlZ3VsYXIgY2FwdHVyZVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldChtb3ZlLnRvLCB7IHR5cGU6IG1vdmUuY2FwdHVyZWQsIGNvbG9yOiB0aGVtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuS1NJREVfQ0FTVExFIHwgQklUUy5RU0lERV9DQVNUTEUpKSB7XG4gICAgICAgICAgICBsZXQgY2FzdGxpbmdUbywgY2FzdGxpbmdGcm9tO1xuICAgICAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nVG8gPSBtb3ZlLnRvICsgMTtcbiAgICAgICAgICAgICAgICBjYXN0bGluZ0Zyb20gPSBtb3ZlLnRvIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nVG8gPSBtb3ZlLnRvIC0gMjtcbiAgICAgICAgICAgICAgICBjYXN0bGluZ0Zyb20gPSBtb3ZlLnRvICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21vdmVQaWVjZShjYXN0bGluZ0Zyb20sIGNhc3RsaW5nVG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3ZlO1xuICAgIH1cbiAgICBwZ24oeyBuZXdsaW5lID0gJ1xcbicsIG1heFdpZHRoID0gMCwgfSA9IHt9KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIHVzaW5nIHRoZSBzcGVjaWZpY2F0aW9uIGZyb20gaHR0cDovL3d3dy5jaGVzc2NsdWIuY29tL2hlbHAvUEdOLXNwZWNcbiAgICAgICAgICogZXhhbXBsZSBmb3IgaHRtbCB1c2FnZTogLnBnbih7IG1heF93aWR0aDogNzIsIG5ld2xpbmVfY2hhcjogXCI8YnIgLz5cIiB9KVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBoZWFkZXJFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgLyogYWRkIHRoZSBQR04gaGVhZGVyIGluZm9ybWF0aW9uICovXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9oZWFkZXIpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUT0RPOiBvcmRlciBvZiBlbnVtZXJhdGVkIHByb3BlcnRpZXMgaW4gaGVhZGVyIG9iamVjdCBpcyBub3RcbiAgICAgICAgICAgICAqIGd1YXJhbnRlZWQsIHNlZSBFQ01BLTI2MiBzcGVjIChzZWN0aW9uIDEyLjYuNClcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBCeSB1c2luZyBIRUFERVJfVEVNUExBVEUsIHRoZSBvcmRlciBvZiB0YWdzIHNob3VsZCBiZSBwcmVzZXJ2ZWQ7IHdlXG4gICAgICAgICAgICAgKiBkbyBoYXZlIHRvIGNoZWNrIGZvciBudWxsIHBsYWNlaG9sZGVycywgdGhvdWdoLCBhbmQgb21pdCB0aGVtXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclRhZyA9IHRoaXMuX2hlYWRlcltpXTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJUYWcpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYFske2l9IFwiJHt0aGlzLl9oZWFkZXJbaV19XCJdYCArIG5ld2xpbmUpO1xuICAgICAgICAgICAgaGVhZGVyRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyRXhpc3RzICYmIHRoaXMuX2hpc3RvcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBlbmRDb21tZW50ID0gKG1vdmVTdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxpbWl0ZXIgPSBtb3ZlU3RyaW5nLmxlbmd0aCA+IDAgPyAnICcgOiAnJztcbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gYCR7bW92ZVN0cmluZ30ke2RlbGltaXRlcn17JHtjb21tZW50fX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vdmVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHBvcCBhbGwgb2YgaGlzdG9yeSBvbnRvIHJldmVyc2VkX2hpc3RvcnlcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vdmVzID0gW107XG4gICAgICAgIGxldCBtb3ZlU3RyaW5nID0gJyc7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBvZiBhIGNvbW1lbnRlZCBzdGFydGluZyBwb3NpdGlvbiB3aXRoIG5vIG1vdmVzXG4gICAgICAgIGlmIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGFwcGVuZENvbW1lbnQoJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCB0aGUgbGlzdCBvZiBtb3Zlcy4gIGEgbW92ZV9zdHJpbmcgbG9va3MgbGlrZTogXCIzLiBlMyBlNlwiXG4gICAgICAgIHdoaWxlIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbW92ZVN0cmluZyA9IGFwcGVuZENvbW1lbnQobW92ZVN0cmluZyk7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgLy8gbWFrZSBUeXBlU2NyaXB0IHN0b3AgY29tcGxhaW5pbmcgYWJvdXQgbW92ZSBiZWluZyB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghbW92ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHBvc2l0aW9uIHN0YXJ0ZWQgd2l0aCBibGFjayB0byBtb3ZlLCBzdGFydCBQR04gd2l0aCAjLiAuLi5cbiAgICAgICAgICAgIGlmICghdGhpcy5faGlzdG9yeS5sZW5ndGggJiYgbW92ZS5jb2xvciA9PT0gJ2InKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYCR7dGhpcy5fbW92ZU51bWJlcn0uIC4uLmA7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlcmUgYSBjb21tZW50IHByZWNlZGluZyB0aGUgZmlyc3QgbW92ZT9cbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gbW92ZVN0cmluZyA/IGAke21vdmVTdHJpbmd9ICR7cHJlZml4fWAgOiBwcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb3ZlLmNvbG9yID09PSAndycpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgZ2VuZXJhdGVkIG1vdmVfc3RyaW5nIGlmIHdlIGhhdmUgb25lXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVzLnB1c2gobW92ZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSB0aGlzLl9tb3ZlTnVtYmVyICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW92ZVN0cmluZyA9XG4gICAgICAgICAgICAgICAgbW92ZVN0cmluZyArICcgJyArIHRoaXMuX21vdmVUb1Nhbihtb3ZlLCB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFyZSB0aGVyZSBhbnkgb3RoZXIgbGVmdG92ZXIgbW92ZXM/XG4gICAgICAgIGlmIChtb3ZlU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgbW92ZXMucHVzaChhcHBlbmRDb21tZW50KG1vdmVTdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpcyB0aGVyZSBhIHJlc3VsdD8gKHRoZXJlIEFMV0FZUyBoYXMgdG8gYmUgYSByZXN1bHQgYWNjb3JkaW5nIHRvIHNwZWM7IHNlZSBTZXZlbiBUYWcgUm9zdGVyKVxuICAgICAgICBtb3Zlcy5wdXNoKHRoaXMuX2hlYWRlci5SZXN1bHQgfHwgJyonKTtcbiAgICAgICAgLypcbiAgICAgICAgICogaGlzdG9yeSBzaG91bGQgYmUgYmFjayB0byB3aGF0IGl0IHdhcyBiZWZvcmUgd2Ugc3RhcnRlZCBnZW5lcmF0aW5nIFBHTixcbiAgICAgICAgICogc28gam9pbiB0b2dldGhlciBtb3Zlc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG1heFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpICsgbW92ZXMuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gKGphaCk6IGh1aD9cbiAgICAgICAgY29uc3Qgc3RyaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBOQjogdGhpcyBkb2VzIG5vdCBwcmVzZXJ2ZSBjb21tZW50IHdoaXRlc3BhY2UuXG4gICAgICAgIGNvbnN0IHdyYXBDb21tZW50ID0gZnVuY3Rpb24gKHdpZHRoLCBtb3ZlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIG1vdmUuc3BsaXQoJyAnKSkge1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCArIHRva2VuLmxlbmd0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHJpcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB3aWR0aCArPSB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICB3aWR0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmlwKCkpIHtcbiAgICAgICAgICAgICAgICB3aWR0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICB9O1xuICAgICAgICAvLyB3cmFwIHRoZSBQR04gb3V0cHV0IGF0IG1heF93aWR0aFxuICAgICAgICBsZXQgY3VycmVudFdpZHRoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3Zlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCArIG1vdmVzW2ldLmxlbmd0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVzW2ldLmluY2x1ZGVzKCd7JykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFdpZHRoID0gd3JhcENvbW1lbnQoY3VycmVudFdpZHRoLCBtb3Zlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG1vdmUgd2lsbCBwdXNoIHBhc3QgbWF4X3dpZHRoXG4gICAgICAgICAgICBpZiAoY3VycmVudFdpZHRoICsgbW92ZXNbaV0ubGVuZ3RoID4gbWF4V2lkdGggJiYgaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGVuZCB0aGUgbGluZSB3aXRoIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobW92ZXNbaV0pO1xuICAgICAgICAgICAgY3VycmVudFdpZHRoICs9IG1vdmVzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHNldEhlYWRlcmAgYW5kIGBnZXRIZWFkZXJzYCBpbnN0ZWFkLiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBudWxsIGhlYWRlciB0YWdzICh3aGljaCBpcyBub3Qgd2hhdCB5b3Ugd2FudClcbiAgICAgKi9cbiAgICBoZWFkZXIoLi4uYXJncykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3NbaSArIDFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlclthcmdzW2ldXSA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfVxuICAgIC8vIFRPRE86IHZhbHVlIHZhbGlkYXRpb24gcGVyIHNwZWNcbiAgICBzZXRIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZWFkZXJba2V5XSA9IHZhbHVlID8/IFNFVkVOX1RBR19ST1NURVJba2V5XSA/PyBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkZXJzKCk7XG4gICAgfVxuICAgIHJlbW92ZUhlYWRlcihrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9oZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcltrZXldID0gU0VWRU5fVEFHX1JPU1RFUltrZXldIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJldHVybiBvbmx5IG5vbi1udWxsIGhlYWRlcnMgKG9taXQgcGxhY2VtYXJrZXIgbnVsbHMpXG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3Qgbm9uTnVsbEhlYWRlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5faGVhZGVyKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm9uTnVsbEhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub25OdWxsSGVhZGVycztcbiAgICB9XG4gICAgbG9hZFBnbihwZ24sIHsgc3RyaWN0ID0gZmFsc2UsIG5ld2xpbmVDaGFyID0gJ1xccj9cXG4nLCB9ID0ge30pIHtcbiAgICAgICAgLy8gSWYgbmV3bGluZUNoYXIgaXMgbm90IHRoZSBkZWZhdWx0LCByZXBsYWNlIGFsbCBpbnN0YW5jZXMgd2l0aCBcXG5cbiAgICAgICAgaWYgKG5ld2xpbmVDaGFyICE9PSAnXFxyP1xcbicpIHtcbiAgICAgICAgICAgIHBnbiA9IHBnbi5yZXBsYWNlKG5ldyBSZWdFeHAobmV3bGluZUNoYXIsICdnJyksICdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRQZ24gPSBwZWckcGFyc2UocGduKTtcbiAgICAgICAgLy8gUHV0IHRoZSBib2FyZCBpbiB0aGUgc3RhcnRpbmcgcG9zaXRpb25cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAvLyBwYXJzZSBQR04gaGVhZGVyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJzZWRQZ24uaGVhZGVycztcbiAgICAgICAgbGV0IGZlbiA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgdXNlciBpcyBpbmNsdWRpbmcgZmVuIChwb3NzaWJseSB3aXRoIHdyb25nIHRhZyBjYXNlKVxuICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnZmVuJykge1xuICAgICAgICAgICAgICAgIGZlbiA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiB0aGUgcGVybWlzc2l2ZSBwYXJzZXIgc2hvdWxkIGF0dGVtcHQgdG8gbG9hZCBhIGZlbiB0YWcsIGV2ZW4gaWYgaXQncyB0aGVcbiAgICAgICAgICogd3JvbmcgY2FzZSBhbmQgZG9lc24ndCBpbmNsdWRlIGEgY29ycmVzcG9uZGluZyBbU2V0VXAgXCIxXCJdIHRhZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoZmVuLCB7IHByZXNlcnZlSGVhZGVyczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBzdHJpY3QgcGFyc2VyIC0gbG9hZCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaW5kaWNhdGVkIGJ5IFtTZXR1cCAnMSddXG4gICAgICAgICAgICAgKiBhbmQgW0ZFTiBwb3NpdGlvbl1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ1NldFVwJ10gPT09ICcxJykge1xuICAgICAgICAgICAgICAgIGlmICghKCdGRU4nIGluIGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQR046IEZFTiB0YWcgbXVzdCBiZSBzdXBwbGllZCB3aXRoIFNldFVwIHRhZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBjbGVhciB0aGUgaGVhZGVycyB3aGVuIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoaGVhZGVyc1snRkVOJ10sIHsgcHJlc2VydmVIZWFkZXJzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gcGFyc2VkUGduLnJvb3Q7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5tb3ZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW92ZSA9IHRoaXMuX21vdmVGcm9tU2FuKG5vZGUubW92ZSwgc3RyaWN0KTtcbiAgICAgICAgICAgICAgICBpZiAobW92ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb3ZlIGluIFBHTjogJHtub2RlLm1vdmV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5jUG9zaXRpb25Db3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldID0gbm9kZS5jb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUudmFyaWF0aW9uc1swXTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBQZXIgc2VjdGlvbiA4LjIuNiBvZiB0aGUgUEdOIHNwZWMsIHRoZSBSZXN1bHQgdGFnIHBhaXIgbXVzdCBtYXRjaCBtYXRjaFxuICAgICAgICAgKiB0aGUgdGVybWluYXRpb24gbWFya2VyLiBPbmx5IGRvIHRoaXMgd2hlbiBoZWFkZXJzIGFyZSBwcmVzZW50LCBidXQgdGhlXG4gICAgICAgICAqIHJlc3VsdCB0YWcgaXMgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VkUGduLnJlc3VsdDtcbiAgICAgICAgaWYgKHJlc3VsdCAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5faGVhZGVyKS5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnUmVzdWx0J10gIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXIoJ1Jlc3VsdCcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGEgbW92ZSBmcm9tIDB4ODggY29vcmRpbmF0ZXMgdG8gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uXG4gICAgICogKFNBTilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RyaWN0IFVzZSB0aGUgc3RyaWN0IFNBTiBwYXJzZXIuIEl0IHdpbGwgdGhyb3cgZXJyb3JzXG4gICAgICogb24gb3Zlcmx5IGRpc2FtYmlndWF0ZWQgbW92ZXMgKHNlZSBiZWxvdyk6XG4gICAgICpcbiAgICAgKiByMWJxa2Juci9wcHAycHBwLzJuNS8xQjFwUDMvNFAzLzgvUFBQUDJQUC9STkJRSzFOUiBiIEtRa3EgLSAyIDRcbiAgICAgKiA0LiAuLi4gTmdlNyBpcyBvdmVybHkgZGlzYW1iaWd1YXRlZCBiZWNhdXNlIHRoZSBrbmlnaHQgb24gYzYgaXMgcGlubmVkXG4gICAgICogNC4gLi4uIE5lNyBpcyB0ZWNobmljYWxseSB0aGUgdmFsaWQgU0FOXG4gICAgICovXG4gICAgX21vdmVUb1Nhbihtb3ZlLCBtb3Zlcykge1xuICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICdPLU8nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgb3V0cHV0ID0gJ08tTy1PJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5OVUxMX01PVkUpIHtcbiAgICAgICAgICAgIHJldHVybiBTQU5fTlVMTE1PVkU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW92ZS5waWVjZSAhPT0gUEFXTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FtYmlndWF0b3IgPSBnZXREaXNhbWJpZ3VhdG9yKG1vdmUsIG1vdmVzKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gbW92ZS5waWVjZS50b1VwcGVyQ2FzZSgpICsgZGlzYW1iaWd1YXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5waWVjZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUuZnJvbSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAneCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUudG8pO1xuICAgICAgICAgICAgaWYgKG1vdmUucHJvbW90aW9uKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICc9JyArIG1vdmUucHJvbW90aW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2soKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDaGVja21hdGUoKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnIyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJysnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgYSBtb3ZlIGZyb20gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHRvIDB4ODggY29vcmRpbmF0ZXNcbiAgICBfbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0ID0gZmFsc2UpIHtcbiAgICAgICAgLy8gc3RyaXAgb2ZmIGFueSBtb3ZlIGRlY29yYXRpb25zOiBlLmcgTmYzKz8hIGJlY29tZXMgTmYzXG4gICAgICAgIGxldCBjbGVhbk1vdmUgPSBzdHJpcHBlZFNhbihtb3ZlKTtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChjbGVhbk1vdmUgPT09ICcwLTAnKSB7XG4gICAgICAgICAgICAgICAgY2xlYW5Nb3ZlID0gJ08tTyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbGVhbk1vdmUgPT09ICcwLTAtMCcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbk1vdmUgPSAnTy1PLU8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZmlyc3QgaW1wbGVtZW50YXRpb24gb2YgbnVsbCB3aXRoIGEgZHVtbXkgbW92ZSAoYmxhY2sga2luZyBtb3ZlcyBmcm9tIGE4IHRvIGE4KSwgbWF5YmUgdGhpcyBjYW4gYmUgaW1wbGVtZW50ZWQgYmV0dGVyXG4gICAgICAgIGlmIChjbGVhbk1vdmUgPT0gU0FOX05VTExNT1ZFKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuX3R1cm4sXG4gICAgICAgICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICAgICAgICB0bzogMCxcbiAgICAgICAgICAgICAgICBwaWVjZTogJ2snLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBCSVRTLk5VTExfTU9WRSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwaWVjZVR5cGUgPSBpbmZlclBpZWNlVHlwZShjbGVhbk1vdmUpO1xuICAgICAgICBsZXQgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiB0cnVlLCBwaWVjZTogcGllY2VUeXBlIH0pO1xuICAgICAgICAvLyBzdHJpY3QgcGFyc2VyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGNsZWFuTW92ZSA9PT0gc3RyaXBwZWRTYW4odGhpcy5fbW92ZVRvU2FuKG1vdmVzW2ldLCBtb3ZlcykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBzdHJpY3QgcGFyc2VyIGZhaWxlZFxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGllY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBtYXRjaGVzID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHRvID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcHJvbW90aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBwZXJtaXNzaXZlIChub24tc3RyaWN0KSBwYXJzZXIgYWxsb3dzIHRoZSB1c2VyIHRvIHBhcnNlXG4gICAgICAgICAqIG5vbi1zdGFuZGFyZCBjaGVzcyBub3RhdGlvbnMuIFRoaXMgcGFyc2VyIGlzIG9ubHkgcnVuIGFmdGVyIHRoZSBzdHJpY3RcbiAgICAgICAgICogU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHBhcnNlciBoYXMgZmFpbGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHJ1bm5pbmcgdGhlIHBlcm1pc3NpdmUgcGFyc2VyLCB3ZSdsbCBydW4gYSByZWdleCB0byBncmFiIHRoZSBwaWVjZSwgdGhlXG4gICAgICAgICAqIHRvL2Zyb20gc3F1YXJlLCBhbmQgYW4gb3B0aW9uYWwgcHJvbW90aW9uIHBpZWNlLiBUaGlzIHJlZ2V4IHdpbGxcbiAgICAgICAgICogcGFyc2UgY29tbW9uIG5vbi1zdGFuZGFyZCBub3RhdGlvbiBsaWtlOiBQZTItZTQsIFJjMWM0LCBRZjN4ZjcsXG4gICAgICAgICAqIGY3ZjhxLCBiMWMzXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFNvbWUgcG9zaXRpb25zIGFuZCBtb3ZlcyBtYXkgYmUgYW1iaWd1b3VzIHdoZW4gdXNpbmcgdGhlIHBlcm1pc3NpdmVcbiAgICAgICAgICogcGFyc2VyLiBGb3IgZXhhbXBsZSwgaW4gdGhpcyBwb3NpdGlvbjogNmsxLzgvOC9CNy84LzgvOC9CTjRLMSB3IC0gLSAwIDEsXG4gICAgICAgICAqIHRoZSBtb3ZlIGIxYzMgbWF5IGJlIGludGVycHJldGVkIGFzIE5jMyBvciBCMWMzIChhIGRpc2FtYmlndWF0ZWQgYmlzaG9wXG4gICAgICAgICAqIG1vdmUpLiBJbiB0aGVzZSBjYXNlcywgdGhlIHBlcm1pc3NpdmUgcGFyc2VyIHdpbGwgZGVmYXVsdCB0byB0aGUgbW9zdFxuICAgICAgICAgKiBiYXNpYyBpbnRlcnByZXRhdGlvbiAod2hpY2ggaXMgYjFjMyBwYXJzaW5nIHRvIE5jMykuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgb3Zlcmx5RGlzYW1iaWd1YXRlZCA9IGZhbHNlO1xuICAgICAgICBtYXRjaGVzID0gY2xlYW5Nb3ZlLm1hdGNoKC8oW3BuYnJxa1BOQlJRS10pPyhbYS1oXVsxLThdKXg/LT8oW2EtaF1bMS04XSkoW3FyYm5RUkJOXSk/Lyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICBwaWVjZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBmcm9tID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgIHRvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIHByb21vdGlvbiA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIG92ZXJseURpc2FtYmlndWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoZSBbYS1oXT9bMS04XT8gcG9ydGlvbiBvZiB0aGUgcmVnZXggYmVsb3cgaGFuZGxlcyBtb3ZlcyB0aGF0IG1heSBiZVxuICAgICAgICAgICAgICogb3Zlcmx5IGRpc2FtYmlndWF0ZWQgKGUuZy4gTmdlNyBpcyB1bm5lY2Vzc2FyeSBhbmQgbm9uLXN0YW5kYXJkIHdoZW5cbiAgICAgICAgICAgICAqIHRoZXJlIGlzIG9uZSBsZWdhbCBrbmlnaHQgbW92ZSB0byBlNykuIEluIHRoaXMgY2FzZSwgdGhlIHZhbHVlIG9mXG4gICAgICAgICAgICAgKiAnZnJvbScgdmFyaWFibGUgd2lsbCBiZSBhIHJhbmsgb3IgZmlsZSwgbm90IGEgc3F1YXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYXRjaGVzID0gY2xlYW5Nb3ZlLm1hdGNoKC8oW3BuYnJxa1BOQlJRS10pPyhbYS1oXT9bMS04XT8peD8tPyhbYS1oXVsxLThdKShbcXJiblFSQk5dKT8vKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcGllY2UgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgIGZyb20gPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgICAgIHRvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgICBwcm9tb3Rpb24gPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJseURpc2FtYmlndWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwaWVjZVR5cGUgPSBpbmZlclBpZWNlVHlwZShjbGVhbk1vdmUpO1xuICAgICAgICBtb3ZlcyA9IHRoaXMuX21vdmVzKHtcbiAgICAgICAgICAgIGxlZ2FsOiB0cnVlLFxuICAgICAgICAgICAgcGllY2U6IHBpZWNlID8gcGllY2UgOiBwaWVjZVR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZyb20gc3F1YXJlLCBpdCBjb3VsZCBiZSBqdXN0ICd4JyBtaXNzaW5nIGZyb20gYSBjYXB0dXJlXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuTW92ZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgc3RyaXBwZWRTYW4odGhpcy5fbW92ZVRvU2FuKG1vdmVzW2ldLCBtb3ZlcykpLnJlcGxhY2UoJ3gnLCAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYW5kLWNvbXBhcmUgbW92ZSBwcm9wZXJ0aWVzIHdpdGggdGhlIHJlc3VsdHMgZnJvbSBvdXIgcGVybWlzc2l2ZSByZWdleFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKCFwaWVjZSB8fCBwaWVjZS50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnBpZWNlKSAmJlxuICAgICAgICAgICAgICAgIE94ODhbZnJvbV0gPT0gbW92ZXNbaV0uZnJvbSAmJlxuICAgICAgICAgICAgICAgIE94ODhbdG9dID09IG1vdmVzW2ldLnRvICYmXG4gICAgICAgICAgICAgICAgKCFwcm9tb3Rpb24gfHwgcHJvbW90aW9uLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucHJvbW90aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJseURpc2FtYmlndWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFNQRUNJQUwgQ0FTRTogd2UgcGFyc2VkIGEgbW92ZSBzdHJpbmcgdGhhdCBtYXkgaGF2ZSBhbiB1bm5lZWRlZFxuICAgICAgICAgICAgICAgICAqIHJhbmsvZmlsZSBkaXNhbWJpZ3VhdG9yIChlLmcuIE5nZTcpLiAgVGhlICdmcm9tJyB2YXJpYWJsZSB3aWxsXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gYWxnZWJyYWljKG1vdmVzW2ldLmZyb20pO1xuICAgICAgICAgICAgICAgIGlmICgoIXBpZWNlIHx8IHBpZWNlLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucGllY2UpICYmXG4gICAgICAgICAgICAgICAgICAgIE94ODhbdG9dID09IG1vdmVzW2ldLnRvICYmXG4gICAgICAgICAgICAgICAgICAgIChmcm9tID09IHNxdWFyZVswXSB8fCBmcm9tID09IHNxdWFyZVsxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9tb3Rpb24gfHwgcHJvbW90aW9uLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucHJvbW90aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW92ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc2NpaSgpIHtcbiAgICAgICAgbGV0IHMgPSAnICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcXG4nO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGRpc3BsYXkgdGhlIHJhbmtcbiAgICAgICAgICAgIGlmIChmaWxlKGkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICcgKyAnODc2NTQzMjEnW3JhbmsoaSldICsgJyB8JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gdGhpcy5fYm9hcmRbaV0udHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuX2JvYXJkW2ldLmNvbG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IGNvbG9yID09PSBXSElURSA/IHBpZWNlLnRvVXBwZXJDYXNlKCkgOiBwaWVjZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHMgKz0gJyAnICsgc3ltYm9sICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyArPSAnIC4gJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSArIDEpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIHMgKz0gJ3xcXG4nO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzICs9ICcgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xcbic7XG4gICAgICAgIHMgKz0gJyAgICAgYSAgYiAgYyAgZCAgZSAgZiAgZyAgaCc7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBwZXJmdChkZXB0aCkge1xuICAgICAgICBjb25zdCBtb3ZlcyA9IHRoaXMuX21vdmVzKHsgbGVnYWw6IGZhbHNlIH0pO1xuICAgICAgICBsZXQgbm9kZXMgPSAwO1xuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuX3R1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZXNbaV0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0tpbmdBdHRhY2tlZChjb2xvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggLSAxID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlcyArPSB0aGlzLnBlcmZ0KGRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBzZXRUdXJuKGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLl90dXJuID09IGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlKCctLScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHVybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R1cm47XG4gICAgfVxuICAgIGJvYXJkKCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgbGV0IHJvdyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZTogYWxnZWJyYWljKGkpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLl9ib2FyZFtpXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5fYm9hcmRbaV0uY29sb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIHJvdyA9IFtdO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBzcXVhcmVDb2xvcihzcXVhcmUpIHtcbiAgICAgICAgaWYgKHNxdWFyZSBpbiBPeDg4KSB7XG4gICAgICAgICAgICBjb25zdCBzcSA9IE94ODhbc3F1YXJlXTtcbiAgICAgICAgICAgIHJldHVybiAocmFuayhzcSkgKyBmaWxlKHNxKSkgJSAyID09PSAwID8gJ2xpZ2h0JyA6ICdkYXJrJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaGlzdG9yeSh7IHZlcmJvc2UgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIGNvbnN0IG1vdmVIaXN0b3J5ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIG1vdmVIaXN0b3J5LnB1c2gobmV3IE1vdmUodGhpcywgbW92ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW92ZUhpc3RvcnkucHVzaCh0aGlzLl9tb3ZlVG9TYW4obW92ZSwgdGhpcy5fbW92ZXMoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmVIaXN0b3J5O1xuICAgIH1cbiAgICAvKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHBvc2l0aW9uIG9jY3VycmVuY2UgY291bnRzIGZvciB0aGUgcHVycG9zZSBvZiByZXBldGl0aW9uXG4gICAgICogY2hlY2tpbmcuIE9sZCBwb3NpdGlvbnMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGlmIHRoZWlyIGNvdW50cyBhcmUgcmVkdWNlZCB0byAwLlxuICAgICAqL1xuICAgIF9nZXRQb3NpdGlvbkNvdW50KGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uQ291bnQuZ2V0KGhhc2gpID8/IDA7XG4gICAgfVxuICAgIF9pbmNQb3NpdGlvbkNvdW50KCkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50LnNldCh0aGlzLl9oYXNoLCAodGhpcy5fcG9zaXRpb25Db3VudC5nZXQodGhpcy5faGFzaCkgPz8gMCkgKyAxKTtcbiAgICB9XG4gICAgX2RlY1Bvc2l0aW9uQ291bnQoaGFzaCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q291bnQgPSB0aGlzLl9wb3NpdGlvbkNvdW50LmdldChoYXNoKSA/PyAwO1xuICAgICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50LmRlbGV0ZShoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uQ291bnQuc2V0KGhhc2gsIGN1cnJlbnRDb3VudCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcnVuZUNvbW1lbnRzKCkge1xuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgY29uc3QgY3VycmVudENvbW1lbnRzID0ge307XG4gICAgICAgIGNvbnN0IGNvcHlDb21tZW50ID0gKGZlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGZlbiBpbiB0aGlzLl9jb21tZW50cykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb21tZW50c1tmZW5dID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29weUNvbW1lbnQodGhpcy5mZW4oKSk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgICAgIGNvcHlDb21tZW50KHRoaXMuZmVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbW1lbnRzID0gY3VycmVudENvbW1lbnRzO1xuICAgIH1cbiAgICBnZXRDb21tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgfVxuICAgIHNldENvbW1lbnQoY29tbWVudCkge1xuICAgICAgICB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXSA9IGNvbW1lbnQucmVwbGFjZSgneycsICdbJykucmVwbGFjZSgnfScsICddJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFJlbmFtZWQgdG8gYHJlbW92ZUNvbW1lbnRgIGZvciBjb25zaXN0ZW5jeVxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNvbW1lbnQoKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbWVudCgpIHtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldO1xuICAgICAgICBkZWxldGUgdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH1cbiAgICBnZXRDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBmZW46IGZlbiwgY29tbWVudDogdGhpcy5fY29tbWVudHNbZmVuXSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBgcmVtb3ZlQ29tbWVudHNgIGZvciBjb25zaXN0ZW5jeVxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDb21tZW50cygpO1xuICAgIH1cbiAgICByZW1vdmVDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1tmZW5dO1xuICAgICAgICAgICAgcmV0dXJuIHsgZmVuOiBmZW4sIGNvbW1lbnQ6IGNvbW1lbnQgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENhc3RsaW5nUmlnaHRzKGNvbG9yLCByaWdodHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzaWRlIG9mIFtLSU5HLCBRVUVFTl0pIHtcbiAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdIHw9IFNJREVTW3NpZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdICY9IH5TSURFU1tzaWRlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRDYXN0bGluZ1JpZ2h0cyhjb2xvcik7XG4gICAgICAgIHJldHVybiAoKHJpZ2h0c1tLSU5HXSA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0c1tLSU5HXSA9PT0gcmVzdWx0W0tJTkddKSAmJlxuICAgICAgICAgICAgKHJpZ2h0c1tRVUVFTl0gPT09IHVuZGVmaW5lZCB8fCByaWdodHNbUVVFRU5dID09PSByZXN1bHRbUVVFRU5dKSk7XG4gICAgfVxuICAgIGdldENhc3RsaW5nUmlnaHRzKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbS0lOR106ICh0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJiBTSURFU1tLSU5HXSkgIT09IDAsXG4gICAgICAgICAgICBbUVVFRU5dOiAodGhpcy5fY2FzdGxpbmdbY29sb3JdICYgU0lERVNbUVVFRU5dKSAhPT0gMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbW92ZU51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdmVOdW1iZXI7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCSVNIT1AsIEJMQUNLLCBDaGVzcywgREVGQVVMVF9QT1NJVElPTiwgS0lORywgS05JR0hULCBNb3ZlLCBQQVdOLCBRVUVFTiwgUk9PSywgU0VWRU5fVEFHX1JPU1RFUiwgU1FVQVJFUywgV0hJVEUsIHZhbGlkYXRlRmVuLCB4b3Jvc2hpcm8xMjggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZXNzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chess.js/dist/esm/chess.js\n");

/***/ })

};
;